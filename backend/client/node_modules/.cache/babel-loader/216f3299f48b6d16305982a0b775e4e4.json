{"ast":null,"code":"import { isValidElement, useRef, useState, useCallback, useEffect, useMemo, createContext, useContext, createElement, cloneElement } from 'react';\n\nvar isHTMLElement = value => value instanceof HTMLElement;\n\nconst EVENTS = {\n  BLUR: 'blur',\n  CHANGE: 'change',\n  INPUT: 'input'\n};\nconst VALIDATION_MODE = {\n  onBlur: 'onBlur',\n  onChange: 'onChange',\n  onSubmit: 'onSubmit',\n  onTouched: 'onTouched',\n  all: 'all'\n};\nconst SELECT = 'select';\nconst UNDEFINED = 'undefined';\nconst INPUT_VALIDATION_RULES = {\n  max: 'max',\n  min: 'min',\n  maxLength: 'maxLength',\n  minLength: 'minLength',\n  pattern: 'pattern',\n  required: 'required',\n  validate: 'validate'\n};\n\nfunction attachEventListeners(_ref, shouldAttachChangeEvent, handleChange) {\n  let {\n    ref\n  } = _ref;\n\n  if (isHTMLElement(ref) && handleChange) {\n    ref.addEventListener(shouldAttachChangeEvent ? EVENTS.CHANGE : EVENTS.INPUT, handleChange);\n    ref.addEventListener(EVENTS.BLUR, handleChange);\n  }\n}\n\nvar isNullOrUndefined = value => value == null;\n\nconst isObjectType = value => typeof value === 'object';\n\nvar isObject = value => !isNullOrUndefined(value) && !Array.isArray(value) && isObjectType(value) && !(value instanceof Date);\n\nvar isKey = value => /^\\w*$/.test(value);\n\nvar compact = value => value.filter(Boolean);\n\nvar stringToPath = input => compact(input.replace(/[\"|']/g, '').replace(/\\[/g, '.').replace(/\\]/g, '').split('.'));\n\nfunction set(object, path, value) {\n  let index = -1;\n  const tempPath = isKey(path) ? [path] : stringToPath(path);\n  const length = tempPath.length;\n  const lastIndex = length - 1;\n\n  while (++index < length) {\n    const key = tempPath[index];\n    let newValue = value;\n\n    if (index !== lastIndex) {\n      const objValue = object[key];\n      newValue = isObject(objValue) || Array.isArray(objValue) ? objValue : !isNaN(+tempPath[index + 1]) ? [] : {};\n    }\n\n    object[key] = newValue;\n    object = object[key];\n  }\n\n  return object;\n}\n\nvar transformToNestObject = function (data) {\n  let value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  for (const key in data) {\n    !isKey(key) ? set(value, key, data[key]) : value[key] = data[key];\n  }\n\n  return value;\n};\n\nvar isUndefined = val => val === undefined;\n\nvar get = function () {\n  let obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  let path = arguments.length > 1 ? arguments[1] : undefined;\n  let defaultValue = arguments.length > 2 ? arguments[2] : undefined;\n  const result = compact(path.split(/[,[\\].]+?/)).reduce((result, key) => isNullOrUndefined(result) ? result : result[key], obj);\n  return isUndefined(result) || result === obj ? isUndefined(obj[path]) ? defaultValue : obj[path] : result;\n};\n\nvar focusOnErrorField = (fields, fieldErrors) => {\n  for (const key in fields) {\n    if (get(fieldErrors, key)) {\n      const field = fields[key];\n\n      if (field) {\n        if (field.ref.focus && isUndefined(field.ref.focus())) {\n          break;\n        } else if (field.options) {\n          field.options[0].ref.focus();\n          break;\n        }\n      }\n    }\n  }\n};\n\nvar removeAllEventListeners = (ref, validateWithStateUpdate) => {\n  if (isHTMLElement(ref) && ref.removeEventListener) {\n    ref.removeEventListener(EVENTS.INPUT, validateWithStateUpdate);\n    ref.removeEventListener(EVENTS.CHANGE, validateWithStateUpdate);\n    ref.removeEventListener(EVENTS.BLUR, validateWithStateUpdate);\n  }\n};\n\nconst defaultReturn = {\n  isValid: false,\n  value: null\n};\n\nvar getRadioValue = options => Array.isArray(options) ? options.reduce((previous, option) => option && option.ref.checked ? {\n  isValid: true,\n  value: option.ref.value\n} : previous, defaultReturn) : defaultReturn;\n\nvar getMultipleSelectValue = options => [...options].filter(_ref2 => {\n  let {\n    selected\n  } = _ref2;\n  return selected;\n}).map(_ref3 => {\n  let {\n    value\n  } = _ref3;\n  return value;\n});\n\nvar isRadioInput = element => element.type === 'radio';\n\nvar isFileInput = element => element.type === 'file';\n\nvar isCheckBoxInput = element => element.type === 'checkbox';\n\nvar isMultipleSelect = element => element.type === `${SELECT}-multiple`;\n\nconst defaultResult = {\n  value: false,\n  isValid: false\n};\nconst validResult = {\n  value: true,\n  isValid: true\n};\n\nvar getCheckboxValue = options => {\n  if (Array.isArray(options)) {\n    if (options.length > 1) {\n      const values = options.filter(option => option && option.ref.checked).map(_ref4 => {\n        let {\n          ref: {\n            value\n          }\n        } = _ref4;\n        return value;\n      });\n      return {\n        value: values,\n        isValid: !!values.length\n      };\n    }\n\n    const {\n      checked,\n      value,\n      attributes\n    } = options[0].ref;\n    return checked ? attributes && !isUndefined(attributes.value) ? isUndefined(value) || value === '' ? validResult : {\n      value: value,\n      isValid: true\n    } : validResult : defaultResult;\n  }\n\n  return defaultResult;\n};\n\nfunction getFieldValue(fieldsRef, name, shallowFieldsStateRef, excludeDisabled, shouldKeepRawValue) {\n  const field = fieldsRef.current[name];\n\n  if (field) {\n    const {\n      ref: {\n        value,\n        disabled\n      },\n      ref,\n      valueAsNumber,\n      valueAsDate,\n      setValueAs\n    } = field;\n\n    if (disabled && excludeDisabled) {\n      return;\n    }\n\n    if (isFileInput(ref)) {\n      return ref.files;\n    }\n\n    if (isRadioInput(ref)) {\n      return getRadioValue(field.options).value;\n    }\n\n    if (isMultipleSelect(ref)) {\n      return getMultipleSelectValue(ref.options);\n    }\n\n    if (isCheckBoxInput(ref)) {\n      return getCheckboxValue(field.options).value;\n    }\n\n    return shouldKeepRawValue ? value : valueAsNumber ? value === '' ? NaN : +value : valueAsDate ? ref.valueAsDate : setValueAs ? setValueAs(value) : value;\n  }\n\n  if (shallowFieldsStateRef) {\n    return get(shallowFieldsStateRef.current, name);\n  }\n}\n\nfunction isDetached(element) {\n  if (!element) {\n    return true;\n  }\n\n  if (!(element instanceof HTMLElement) || element.nodeType === Node.DOCUMENT_NODE) {\n    return false;\n  }\n\n  return isDetached(element.parentNode);\n}\n\nvar isEmptyObject = value => isObject(value) && !Object.keys(value).length;\n\nvar isBoolean = value => typeof value === 'boolean';\n\nfunction baseGet(object, updatePath) {\n  const length = updatePath.slice(0, -1).length;\n  let index = 0;\n\n  while (index < length) {\n    object = isUndefined(object) ? index++ : object[updatePath[index++]];\n  }\n\n  return object;\n}\n\nfunction unset(object, path) {\n  const updatePath = isKey(path) ? [path] : stringToPath(path);\n  const childObject = updatePath.length == 1 ? object : baseGet(object, updatePath);\n  const key = updatePath[updatePath.length - 1];\n  let previousObjRef;\n\n  if (childObject) {\n    delete childObject[key];\n  }\n\n  for (let k = 0; k < updatePath.slice(0, -1).length; k++) {\n    let index = -1;\n    let objectRef;\n    const currentPaths = updatePath.slice(0, -(k + 1));\n    const currentPathsLength = currentPaths.length - 1;\n\n    if (k > 0) {\n      previousObjRef = object;\n    }\n\n    while (++index < currentPaths.length) {\n      const item = currentPaths[index];\n      objectRef = objectRef ? objectRef[item] : object[item];\n\n      if (currentPathsLength === index && (isObject(objectRef) && isEmptyObject(objectRef) || Array.isArray(objectRef) && !objectRef.filter(data => isObject(data) && !isEmptyObject(data) || isBoolean(data)).length)) {\n        previousObjRef ? delete previousObjRef[item] : delete object[item];\n      }\n\n      previousObjRef = objectRef;\n    }\n  }\n\n  return object;\n}\n\nconst isSameRef = (fieldValue, ref) => fieldValue && fieldValue.ref === ref;\n\nfunction findRemovedFieldAndRemoveListener(fieldsRef, handleChange, field, shallowFieldsStateRef, shouldUnregister, forceDelete) {\n  const {\n    ref,\n    ref: {\n      name\n    }\n  } = field;\n  const fieldRef = fieldsRef.current[name];\n\n  if (!shouldUnregister) {\n    const value = getFieldValue(fieldsRef, name, shallowFieldsStateRef);\n    !isUndefined(value) && set(shallowFieldsStateRef.current, name, value);\n  }\n\n  if (!ref.type || !fieldRef) {\n    delete fieldsRef.current[name];\n    return;\n  }\n\n  if (isRadioInput(ref) || isCheckBoxInput(ref)) {\n    if (Array.isArray(fieldRef.options) && fieldRef.options.length) {\n      compact(fieldRef.options).forEach(function () {\n        let option = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        let index = arguments.length > 1 ? arguments[1] : undefined;\n\n        if (isDetached(option.ref) && isSameRef(option, option.ref) || forceDelete) {\n          removeAllEventListeners(option.ref, handleChange);\n          unset(fieldRef.options, `[${index}]`);\n        }\n      });\n\n      if (fieldRef.options && !compact(fieldRef.options).length) {\n        delete fieldsRef.current[name];\n      }\n    } else {\n      delete fieldsRef.current[name];\n    }\n  } else if (isDetached(ref) && isSameRef(fieldRef, ref) || forceDelete) {\n    removeAllEventListeners(ref, handleChange);\n    delete fieldsRef.current[name];\n  }\n}\n\nvar isPrimitive = value => isNullOrUndefined(value) || !isObjectType(value);\n\nfunction deepMerge(target, source) {\n  if (isPrimitive(target) || isPrimitive(source)) {\n    return source;\n  }\n\n  for (const key in source) {\n    const targetValue = target[key];\n    const sourceValue = source[key];\n\n    try {\n      target[key] = isObject(targetValue) && isObject(sourceValue) || Array.isArray(targetValue) && Array.isArray(sourceValue) ? deepMerge(targetValue, sourceValue) : sourceValue;\n    } catch (_a) {}\n  }\n\n  return target;\n}\n\nfunction deepEqual(object1, object2, isErrorObject) {\n  if (isPrimitive(object1) || isPrimitive(object2) || object1 instanceof Date || object2 instanceof Date) {\n    return object1 === object2;\n  }\n\n  if (!isValidElement(object1)) {\n    const keys1 = Object.keys(object1);\n    const keys2 = Object.keys(object2);\n\n    if (keys1.length !== keys2.length) {\n      return false;\n    }\n\n    for (const key of keys1) {\n      const val1 = object1[key];\n\n      if (!(isErrorObject && key === 'ref')) {\n        const val2 = object2[key];\n\n        if ((isObject(val1) || Array.isArray(val1)) && (isObject(val2) || Array.isArray(val2)) ? !deepEqual(val1, val2, isErrorObject) : val1 !== val2) {\n          return false;\n        }\n      }\n    }\n  }\n\n  return true;\n}\n\nfunction setDirtyFields(values, defaultValues, dirtyFields, parentNode, parentName) {\n  let index = -1;\n\n  while (++index < values.length) {\n    for (const key in values[index]) {\n      if (Array.isArray(values[index][key])) {\n        !dirtyFields[index] && (dirtyFields[index] = {});\n        dirtyFields[index][key] = [];\n        setDirtyFields(values[index][key], get(defaultValues[index] || {}, key, []), dirtyFields[index][key], dirtyFields[index], key);\n      } else {\n        deepEqual(get(defaultValues[index] || {}, key), values[index][key]) ? set(dirtyFields[index] || {}, key) : dirtyFields[index] = Object.assign(Object.assign({}, dirtyFields[index]), {\n          [key]: true\n        });\n      }\n    }\n\n    parentNode && !dirtyFields.length && delete parentNode[parentName];\n  }\n\n  return dirtyFields;\n}\n\nvar setFieldArrayDirtyFields = (values, defaultValues, dirtyFields) => deepMerge(setDirtyFields(values, defaultValues, dirtyFields.slice(0, values.length)), setDirtyFields(defaultValues, values, dirtyFields.slice(0, values.length)));\n\nvar isString = value => typeof value === 'string';\n\nvar getFieldsValues = (fieldsRef, shallowFieldsState, shouldUnregister, excludeDisabled, search) => {\n  const output = {};\n\n  for (const name in fieldsRef.current) {\n    if (isUndefined(search) || (isString(search) ? name.startsWith(search) : Array.isArray(search) && search.find(data => name.startsWith(data)))) {\n      output[name] = getFieldValue(fieldsRef, name, undefined, excludeDisabled);\n    }\n  }\n\n  return shouldUnregister ? transformToNestObject(output) : deepMerge(shallowFieldsState, transformToNestObject(output));\n};\n\nvar isErrorStateChanged = _ref5 => {\n  let {\n    errors,\n    name,\n    error,\n    validFields,\n    fieldsWithValidation\n  } = _ref5;\n  const isValid = isUndefined(error);\n  const previousError = get(errors, name);\n  return isValid && !!previousError || !isValid && !deepEqual(previousError, error, true) || isValid && get(fieldsWithValidation, name) && !get(validFields, name);\n};\n\nvar isRegex = value => value instanceof RegExp;\n\nvar getValueAndMessage = validationData => isObject(validationData) && !isRegex(validationData) ? validationData : {\n  value: validationData,\n  message: ''\n};\n\nvar isFunction = value => typeof value === 'function';\n\nvar isMessage = value => isString(value) || isValidElement(value);\n\nfunction getValidateError(result, ref) {\n  let type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'validate';\n\n  if (isMessage(result) || isBoolean(result) && !result) {\n    return {\n      type,\n      message: isMessage(result) ? result : '',\n      ref\n    };\n  }\n}\n\nvar appendErrors = (name, validateAllFieldCriteria, errors, type, message) => validateAllFieldCriteria ? Object.assign(Object.assign({}, errors[name]), {\n  types: Object.assign(Object.assign({}, errors[name] && errors[name].types ? errors[name].types : {}), {\n    [type]: message || true\n  })\n}) : {};\n\nvar validateField = async (fieldsRef, validateAllFieldCriteria, _ref6, shallowFieldsStateRef) => {\n  let {\n    ref,\n    ref: {\n      value\n    },\n    options,\n    required,\n    maxLength,\n    minLength,\n    min,\n    max,\n    pattern,\n    validate\n  } = _ref6;\n  const name = ref.name;\n  const error = {};\n  const isRadio = isRadioInput(ref);\n  const isCheckBox = isCheckBoxInput(ref);\n  const isRadioOrCheckbox = isRadio || isCheckBox;\n  const isEmpty = value === '';\n  const appendErrorsCurry = appendErrors.bind(null, name, validateAllFieldCriteria, error);\n\n  const getMinMaxMessage = function (exceedMax, maxLengthMessage, minLengthMessage) {\n    let maxType = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : INPUT_VALIDATION_RULES.maxLength;\n    let minType = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : INPUT_VALIDATION_RULES.minLength;\n    const message = exceedMax ? maxLengthMessage : minLengthMessage;\n    error[name] = Object.assign({\n      type: exceedMax ? maxType : minType,\n      message,\n      ref\n    }, exceedMax ? appendErrorsCurry(maxType, message) : appendErrorsCurry(minType, message));\n  };\n\n  if (required && (!isRadio && !isCheckBox && (isEmpty || isNullOrUndefined(value)) || isBoolean(value) && !value || isCheckBox && !getCheckboxValue(options).isValid || isRadio && !getRadioValue(options).isValid)) {\n    const {\n      value,\n      message\n    } = isMessage(required) ? {\n      value: !!required,\n      message: required\n    } : getValueAndMessage(required);\n\n    if (value) {\n      error[name] = Object.assign({\n        type: INPUT_VALIDATION_RULES.required,\n        message,\n        ref: isRadioOrCheckbox ? ((fieldsRef.current[name].options || [])[0] || {}).ref : ref\n      }, appendErrorsCurry(INPUT_VALIDATION_RULES.required, message));\n\n      if (!validateAllFieldCriteria) {\n        return error;\n      }\n    }\n  }\n\n  if ((!isNullOrUndefined(min) || !isNullOrUndefined(max)) && value !== '') {\n    let exceedMax;\n    let exceedMin;\n    const maxOutput = getValueAndMessage(max);\n    const minOutput = getValueAndMessage(min);\n\n    if (!isNaN(value)) {\n      const valueNumber = ref.valueAsNumber || parseFloat(value);\n\n      if (!isNullOrUndefined(maxOutput.value)) {\n        exceedMax = valueNumber > maxOutput.value;\n      }\n\n      if (!isNullOrUndefined(minOutput.value)) {\n        exceedMin = valueNumber < minOutput.value;\n      }\n    } else {\n      const valueDate = ref.valueAsDate || new Date(value);\n\n      if (isString(maxOutput.value)) {\n        exceedMax = valueDate > new Date(maxOutput.value);\n      }\n\n      if (isString(minOutput.value)) {\n        exceedMin = valueDate < new Date(minOutput.value);\n      }\n    }\n\n    if (exceedMax || exceedMin) {\n      getMinMaxMessage(!!exceedMax, maxOutput.message, minOutput.message, INPUT_VALIDATION_RULES.max, INPUT_VALIDATION_RULES.min);\n\n      if (!validateAllFieldCriteria) {\n        return error;\n      }\n    }\n  }\n\n  if (isString(value) && !isEmpty && (maxLength || minLength)) {\n    const maxLengthOutput = getValueAndMessage(maxLength);\n    const minLengthOutput = getValueAndMessage(minLength);\n    const exceedMax = !isNullOrUndefined(maxLengthOutput.value) && value.length > maxLengthOutput.value;\n    const exceedMin = !isNullOrUndefined(minLengthOutput.value) && value.length < minLengthOutput.value;\n\n    if (exceedMax || exceedMin) {\n      getMinMaxMessage(exceedMax, maxLengthOutput.message, minLengthOutput.message);\n\n      if (!validateAllFieldCriteria) {\n        return error;\n      }\n    }\n  }\n\n  if (isString(value) && pattern && !isEmpty) {\n    const {\n      value: patternValue,\n      message\n    } = getValueAndMessage(pattern);\n\n    if (isRegex(patternValue) && !patternValue.test(value)) {\n      error[name] = Object.assign({\n        type: INPUT_VALIDATION_RULES.pattern,\n        message,\n        ref\n      }, appendErrorsCurry(INPUT_VALIDATION_RULES.pattern, message));\n\n      if (!validateAllFieldCriteria) {\n        return error;\n      }\n    }\n  }\n\n  if (validate) {\n    const fieldValue = getFieldValue(fieldsRef, name, shallowFieldsStateRef, false, true);\n    const validateRef = isRadioOrCheckbox && options ? options[0].ref : ref;\n\n    if (isFunction(validate)) {\n      const result = await validate(fieldValue);\n      const validateError = getValidateError(result, validateRef);\n\n      if (validateError) {\n        error[name] = Object.assign(Object.assign({}, validateError), appendErrorsCurry(INPUT_VALIDATION_RULES.validate, validateError.message));\n\n        if (!validateAllFieldCriteria) {\n          return error;\n        }\n      }\n    } else if (isObject(validate)) {\n      let validationResult = {};\n\n      for (const [key, validateFunction] of Object.entries(validate)) {\n        if (!isEmptyObject(validationResult) && !validateAllFieldCriteria) {\n          break;\n        }\n\n        const validateResult = await validateFunction(fieldValue);\n        const validateError = getValidateError(validateResult, validateRef, key);\n\n        if (validateError) {\n          validationResult = Object.assign(Object.assign({}, validateError), appendErrorsCurry(key, validateError.message));\n\n          if (validateAllFieldCriteria) {\n            error[name] = validationResult;\n          }\n        }\n      }\n\n      if (!isEmptyObject(validationResult)) {\n        error[name] = Object.assign({\n          ref: validateRef\n        }, validationResult);\n\n        if (!validateAllFieldCriteria) {\n          return error;\n        }\n      }\n    }\n  }\n\n  return error;\n};\n\nconst getPath = function (rootPath, values) {\n  let paths = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n\n  for (const property in values) {\n    const rootName = rootPath + (isObject(values) ? `.${property}` : `[${property}]`);\n    isPrimitive(values[property]) ? paths.push(rootName) : getPath(rootName, values[property], paths);\n  }\n\n  return paths;\n};\n\nvar assignWatchFields = (fieldValues, fieldName, watchFields, inputValue, isSingleField) => {\n  let value = undefined;\n  watchFields.add(fieldName);\n\n  if (!isEmptyObject(fieldValues)) {\n    value = get(fieldValues, fieldName);\n\n    if (isObject(value) || Array.isArray(value)) {\n      getPath(fieldName, value).forEach(name => watchFields.add(name));\n    }\n  }\n\n  return isUndefined(value) ? isSingleField ? inputValue : get(inputValue, fieldName) : value;\n};\n\nvar skipValidation = _ref7 => {\n  let {\n    isOnBlur,\n    isOnChange,\n    isOnTouch,\n    isTouched,\n    isReValidateOnBlur,\n    isReValidateOnChange,\n    isBlurEvent,\n    isSubmitted,\n    isOnAll\n  } = _ref7;\n\n  if (isOnAll) {\n    return false;\n  } else if (!isSubmitted && isOnTouch) {\n    return !(isTouched || isBlurEvent);\n  } else if (isSubmitted ? isReValidateOnBlur : isOnBlur) {\n    return !isBlurEvent;\n  } else if (isSubmitted ? isReValidateOnChange : isOnChange) {\n    return isBlurEvent;\n  }\n\n  return true;\n};\n\nvar getFieldArrayParentName = name => name.substring(0, name.indexOf('['));\n\nconst isMatchFieldArrayName = (name, searchName) => RegExp(`^${searchName}([|.)\\\\d+`.replace(/\\[/g, '\\\\[').replace(/\\]/g, '\\\\]')).test(name);\n\nvar isNameInFieldArray = (names, name) => [...names].some(current => isMatchFieldArrayName(name, current));\n\nvar isSelectInput = element => element.type === `${SELECT}-one`;\n\nfunction onDomRemove(fieldsRef, removeFieldEventListenerAndRef) {\n  const observer = new MutationObserver(() => {\n    for (const field of Object.values(fieldsRef.current)) {\n      if (field && field.options) {\n        for (const option of field.options) {\n          if (option && option.ref && isDetached(option.ref)) {\n            removeFieldEventListenerAndRef(field);\n          }\n        }\n      } else if (field && isDetached(field.ref)) {\n        removeFieldEventListenerAndRef(field);\n      }\n    }\n  });\n  observer.observe(window.document, {\n    childList: true,\n    subtree: true\n  });\n  return observer;\n}\n\nvar isWeb = typeof window !== UNDEFINED && typeof document !== UNDEFINED;\n\nfunction cloneObject(data) {\n  let copy;\n\n  if (isPrimitive(data) || isWeb && (data instanceof File || isHTMLElement(data))) {\n    return data;\n  }\n\n  if (data instanceof Date) {\n    copy = new Date(data.getTime());\n    return copy;\n  }\n\n  if (data instanceof Set) {\n    copy = new Set();\n\n    for (const item of data) {\n      copy.add(item);\n    }\n\n    return copy;\n  }\n\n  if (data instanceof Map) {\n    copy = new Map();\n\n    for (const key of data.keys()) {\n      copy.set(key, cloneObject(data.get(key)));\n    }\n\n    return copy;\n  }\n\n  copy = Array.isArray(data) ? [] : {};\n\n  for (const key in data) {\n    copy[key] = cloneObject(data[key]);\n  }\n\n  return copy;\n}\n\nvar modeChecker = mode => ({\n  isOnSubmit: !mode || mode === VALIDATION_MODE.onSubmit,\n  isOnBlur: mode === VALIDATION_MODE.onBlur,\n  isOnChange: mode === VALIDATION_MODE.onChange,\n  isOnAll: mode === VALIDATION_MODE.all,\n  isOnTouch: mode === VALIDATION_MODE.onTouched\n});\n\nvar isRadioOrCheckboxFunction = ref => isRadioInput(ref) || isCheckBoxInput(ref);\n\nconst isWindowUndefined = typeof window === UNDEFINED;\nconst isProxyEnabled = isWeb ? 'Proxy' in window : typeof Proxy !== UNDEFINED;\n\nfunction useForm() {\n  let {\n    mode = VALIDATION_MODE.onSubmit,\n    reValidateMode = VALIDATION_MODE.onChange,\n    resolver,\n    context,\n    defaultValues = {},\n    shouldFocusError = true,\n    shouldUnregister = true,\n    criteriaMode\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const fieldsRef = useRef({});\n  const fieldArrayDefaultValuesRef = useRef({});\n  const fieldArrayValuesRef = useRef({});\n  const watchFieldsRef = useRef(new Set());\n  const useWatchFieldsRef = useRef({});\n  const useWatchRenderFunctionsRef = useRef({});\n  const fieldsWithValidationRef = useRef({});\n  const validFieldsRef = useRef({});\n  const defaultValuesRef = useRef(defaultValues);\n  const isUnMount = useRef(false);\n  const isWatchAllRef = useRef(false);\n  const handleChangeRef = useRef();\n  const shallowFieldsStateRef = useRef({});\n  const resetFieldArrayFunctionRef = useRef({});\n  const contextRef = useRef(context);\n  const resolverRef = useRef(resolver);\n  const fieldArrayNamesRef = useRef(new Set());\n  const modeRef = useRef(modeChecker(mode));\n  const {\n    isOnSubmit,\n    isOnTouch\n  } = modeRef.current;\n  const isValidateAllFieldCriteria = criteriaMode === VALIDATION_MODE.all;\n  const [formState, setFormState] = useState({\n    isDirty: false,\n    isValidating: false,\n    dirtyFields: {},\n    isSubmitted: false,\n    submitCount: 0,\n    touched: {},\n    isSubmitting: false,\n    isSubmitSuccessful: false,\n    isValid: !isOnSubmit,\n    errors: {}\n  });\n  const readFormStateRef = useRef({\n    isDirty: !isProxyEnabled,\n    dirtyFields: !isProxyEnabled,\n    touched: !isProxyEnabled || isOnTouch,\n    isValidating: !isProxyEnabled,\n    isSubmitting: !isProxyEnabled,\n    isValid: !isProxyEnabled\n  });\n  const formStateRef = useRef(formState);\n  const observerRef = useRef();\n  const {\n    isOnBlur: isReValidateOnBlur,\n    isOnChange: isReValidateOnChange\n  } = useRef(modeChecker(reValidateMode)).current;\n  contextRef.current = context;\n  resolverRef.current = resolver;\n  formStateRef.current = formState;\n  shallowFieldsStateRef.current = shouldUnregister ? {} : isEmptyObject(shallowFieldsStateRef.current) ? cloneObject(defaultValues) : shallowFieldsStateRef.current;\n  const updateFormState = useCallback(function () {\n    let state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (!isUnMount.current) {\n      formStateRef.current = Object.assign(Object.assign({}, formStateRef.current), state);\n      setFormState(formStateRef.current);\n    }\n  }, []);\n\n  const updateIsValidating = () => readFormStateRef.current.isValidating && updateFormState({\n    isValidating: true\n  });\n\n  const shouldRenderBaseOnError = useCallback(function (name, error) {\n    let shouldRender = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    let state = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    let isValid = arguments.length > 4 ? arguments[4] : undefined;\n    let shouldReRender = shouldRender || isErrorStateChanged({\n      errors: formStateRef.current.errors,\n      error,\n      name,\n      validFields: validFieldsRef.current,\n      fieldsWithValidation: fieldsWithValidationRef.current\n    });\n    const previousError = get(formStateRef.current.errors, name);\n\n    if (error) {\n      unset(validFieldsRef.current, name);\n      shouldReRender = shouldReRender || !previousError || !deepEqual(previousError, error, true);\n      set(formStateRef.current.errors, name, error);\n    } else {\n      if (get(fieldsWithValidationRef.current, name) || resolverRef.current) {\n        set(validFieldsRef.current, name, true);\n        shouldReRender = shouldReRender || previousError;\n      }\n\n      unset(formStateRef.current.errors, name);\n    }\n\n    if (shouldReRender && !isNullOrUndefined(shouldRender) || !isEmptyObject(state) || readFormStateRef.current.isValidating) {\n      updateFormState(Object.assign(Object.assign(Object.assign({}, state), resolverRef.current ? {\n        isValid: !!isValid\n      } : {}), {\n        isValidating: false\n      }));\n    }\n  }, []);\n  const setFieldValue = useCallback((name, rawValue) => {\n    const {\n      ref,\n      options\n    } = fieldsRef.current[name];\n    const value = isWeb && isHTMLElement(ref) && isNullOrUndefined(rawValue) ? '' : rawValue;\n\n    if (isRadioInput(ref)) {\n      (options || []).forEach(_ref8 => {\n        let {\n          ref: radioRef\n        } = _ref8;\n        return radioRef.checked = radioRef.value === value;\n      });\n    } else if (isFileInput(ref) && !isString(value)) {\n      ref.files = value;\n    } else if (isMultipleSelect(ref)) {\n      [...ref.options].forEach(selectRef => selectRef.selected = value.includes(selectRef.value));\n    } else if (isCheckBoxInput(ref) && options) {\n      options.length > 1 ? options.forEach(_ref9 => {\n        let {\n          ref: checkboxRef\n        } = _ref9;\n        return checkboxRef.checked = Array.isArray(value) ? !!value.find(data => data === checkboxRef.value) : value === checkboxRef.value;\n      }) : options[0].ref.checked = !!value;\n    } else {\n      ref.value = value;\n    }\n  }, []);\n  const isFormDirty = useCallback((name, data) => {\n    if (readFormStateRef.current.isDirty) {\n      const formValues = getValues();\n      name && data && set(formValues, name, data);\n      return !deepEqual(formValues, defaultValuesRef.current);\n    }\n\n    return false;\n  }, []);\n  const updateAndGetDirtyState = useCallback(function (name) {\n    let shouldRender = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n    if (readFormStateRef.current.isDirty || readFormStateRef.current.dirtyFields) {\n      const isFieldDirty = !deepEqual(get(defaultValuesRef.current, name), getFieldValue(fieldsRef, name, shallowFieldsStateRef));\n      const isDirtyFieldExist = get(formStateRef.current.dirtyFields, name);\n      const previousIsDirty = formStateRef.current.isDirty;\n      isFieldDirty ? set(formStateRef.current.dirtyFields, name, true) : unset(formStateRef.current.dirtyFields, name);\n      const state = {\n        isDirty: isFormDirty(),\n        dirtyFields: formStateRef.current.dirtyFields\n      };\n      const isChanged = readFormStateRef.current.isDirty && previousIsDirty !== state.isDirty || readFormStateRef.current.dirtyFields && isDirtyFieldExist !== get(formStateRef.current.dirtyFields, name);\n      isChanged && shouldRender && updateFormState(state);\n      return isChanged ? state : {};\n    }\n\n    return {};\n  }, []);\n  const executeValidation = useCallback(async (name, skipReRender) => {\n    if (process.env.NODE_ENV !== 'production') {\n      if (!fieldsRef.current[name]) {\n        console.warn('📋 Field is missing with `name` attribute: ', name);\n        return false;\n      }\n    }\n\n    const error = (await validateField(fieldsRef, isValidateAllFieldCriteria, fieldsRef.current[name], shallowFieldsStateRef))[name];\n    shouldRenderBaseOnError(name, error, skipReRender);\n    return isUndefined(error);\n  }, [shouldRenderBaseOnError, isValidateAllFieldCriteria]);\n  const executeSchemaOrResolverValidation = useCallback(async names => {\n    const {\n      errors\n    } = await resolverRef.current(getValues(), contextRef.current, isValidateAllFieldCriteria);\n    const previousFormIsValid = formStateRef.current.isValid;\n\n    if (Array.isArray(names)) {\n      const isInputsValid = names.map(name => {\n        const error = get(errors, name);\n        error ? set(formStateRef.current.errors, name, error) : unset(formStateRef.current.errors, name);\n        return !error;\n      }).every(Boolean);\n      updateFormState({\n        isValid: isEmptyObject(errors),\n        isValidating: false\n      });\n      return isInputsValid;\n    } else {\n      const error = get(errors, names);\n      shouldRenderBaseOnError(names, error, previousFormIsValid !== isEmptyObject(errors), {}, isEmptyObject(errors));\n      return !error;\n    }\n  }, [shouldRenderBaseOnError, isValidateAllFieldCriteria]);\n  const trigger = useCallback(async name => {\n    const fields = name || Object.keys(fieldsRef.current);\n    updateIsValidating();\n\n    if (resolverRef.current) {\n      return executeSchemaOrResolverValidation(fields);\n    }\n\n    if (Array.isArray(fields)) {\n      !name && (formStateRef.current.errors = {});\n      const result = await Promise.all(fields.map(async data => await executeValidation(data, null)));\n      updateFormState({\n        isValidating: false\n      });\n      return result.every(Boolean);\n    }\n\n    return await executeValidation(fields);\n  }, [executeSchemaOrResolverValidation, executeValidation]);\n  const setInternalValues = useCallback((name, value, _ref10) => {\n    let {\n      shouldDirty,\n      shouldValidate\n    } = _ref10;\n    const data = {};\n    set(data, name, value);\n\n    for (const fieldName of getPath(name, value)) {\n      if (fieldsRef.current[fieldName]) {\n        setFieldValue(fieldName, get(data, fieldName));\n        shouldDirty && updateAndGetDirtyState(fieldName);\n        shouldValidate && trigger(fieldName);\n      }\n    }\n  }, [trigger, setFieldValue, updateAndGetDirtyState]);\n  const setInternalValue = useCallback((name, value, config) => {\n    !shouldUnregister && !isPrimitive(value) && set(shallowFieldsStateRef.current, name, Object.assign({}, value));\n\n    if (fieldsRef.current[name]) {\n      setFieldValue(name, value);\n      config.shouldDirty && updateAndGetDirtyState(name);\n      config.shouldValidate && trigger(name);\n    } else if (!isPrimitive(value)) {\n      setInternalValues(name, value, config);\n\n      if (fieldArrayNamesRef.current.has(name)) {\n        const parentName = getFieldArrayParentName(name) || name;\n        set(fieldArrayDefaultValuesRef.current, name, value);\n        resetFieldArrayFunctionRef.current[parentName]({\n          [parentName]: get(fieldArrayDefaultValuesRef.current, parentName)\n        });\n\n        if ((readFormStateRef.current.isDirty || readFormStateRef.current.dirtyFields) && config.shouldDirty) {\n          set(formStateRef.current.dirtyFields, name, setFieldArrayDirtyFields(value, get(defaultValuesRef.current, name, []), get(formStateRef.current.dirtyFields, name, [])));\n          updateFormState({\n            isDirty: !deepEqual(Object.assign(Object.assign({}, getValues()), {\n              [name]: value\n            }), defaultValuesRef.current)\n          });\n        }\n      }\n    }\n\n    !shouldUnregister && set(shallowFieldsStateRef.current, name, value);\n  }, [updateAndGetDirtyState, setFieldValue, setInternalValues]);\n\n  const isFieldWatched = name => isWatchAllRef.current || watchFieldsRef.current.has(name) || watchFieldsRef.current.has((name.match(/\\w+/) || [])[0]);\n\n  const renderWatchedInputs = name => {\n    let found = true;\n\n    if (!isEmptyObject(useWatchFieldsRef.current)) {\n      for (const key in useWatchFieldsRef.current) {\n        if (!name || !useWatchFieldsRef.current[key].size || useWatchFieldsRef.current[key].has(name) || useWatchFieldsRef.current[key].has(getFieldArrayParentName(name))) {\n          useWatchRenderFunctionsRef.current[key]();\n          found = false;\n        }\n      }\n    }\n\n    return found;\n  };\n\n  function setValue(name, value, config) {\n    setInternalValue(name, value, config || {});\n    isFieldWatched(name) && updateFormState();\n    renderWatchedInputs(name);\n  }\n\n  handleChangeRef.current = handleChangeRef.current ? handleChangeRef.current : async _ref11 => {\n    let {\n      type,\n      target\n    } = _ref11;\n    let name = target.name;\n    const field = fieldsRef.current[name];\n    let error;\n    let isValid;\n\n    if (field) {\n      const isBlurEvent = type === EVENTS.BLUR;\n      const shouldSkipValidation = skipValidation(Object.assign({\n        isBlurEvent,\n        isReValidateOnChange,\n        isReValidateOnBlur,\n        isTouched: !!get(formStateRef.current.touched, name),\n        isSubmitted: formStateRef.current.isSubmitted\n      }, modeRef.current));\n      let state = updateAndGetDirtyState(name, false);\n      let shouldRender = !isEmptyObject(state) || !isBlurEvent && isFieldWatched(name);\n\n      if (isBlurEvent && !get(formStateRef.current.touched, name) && readFormStateRef.current.touched) {\n        set(formStateRef.current.touched, name, true);\n        state = Object.assign(Object.assign({}, state), {\n          touched: formStateRef.current.touched\n        });\n      }\n\n      if (!shouldUnregister && isCheckBoxInput(target)) {\n        set(shallowFieldsStateRef.current, name, getFieldValue(fieldsRef, name));\n      }\n\n      if (shouldSkipValidation) {\n        !isBlurEvent && renderWatchedInputs(name);\n        return (!isEmptyObject(state) || shouldRender && isEmptyObject(state)) && updateFormState(state);\n      }\n\n      updateIsValidating();\n\n      if (resolverRef.current) {\n        const {\n          errors\n        } = await resolverRef.current(getValues(), contextRef.current, isValidateAllFieldCriteria);\n        const previousFormIsValid = formStateRef.current.isValid;\n        error = get(errors, name);\n\n        if (isCheckBoxInput(target) && !error && resolverRef.current) {\n          const parentNodeName = getFieldArrayParentName(name);\n          const currentError = get(errors, parentNodeName, {});\n          currentError.type && currentError.message && (error = currentError);\n\n          if (parentNodeName && (currentError || get(formStateRef.current.errors, parentNodeName))) {\n            name = parentNodeName;\n          }\n        }\n\n        isValid = isEmptyObject(errors);\n        previousFormIsValid !== isValid && (shouldRender = true);\n      } else {\n        error = (await validateField(fieldsRef, isValidateAllFieldCriteria, field, shallowFieldsStateRef))[name];\n      }\n\n      !isBlurEvent && renderWatchedInputs(name);\n      shouldRenderBaseOnError(name, error, shouldRender, state, isValid);\n    }\n  };\n\n  function setFieldArrayDefaultValues(data) {\n    if (!shouldUnregister) {\n      let copy = cloneObject(data);\n\n      for (const value of fieldArrayNamesRef.current) {\n        if (isKey(value) && !copy[value]) {\n          copy = Object.assign(Object.assign({}, copy), {\n            [value]: []\n          });\n        }\n      }\n\n      return copy;\n    }\n\n    return data;\n  }\n\n  function getValues(payload) {\n    if (isString(payload)) {\n      return getFieldValue(fieldsRef, payload, shallowFieldsStateRef);\n    }\n\n    if (Array.isArray(payload)) {\n      const data = {};\n\n      for (const name of payload) {\n        set(data, name, getFieldValue(fieldsRef, name, shallowFieldsStateRef));\n      }\n\n      return data;\n    }\n\n    return setFieldArrayDefaultValues(getFieldsValues(fieldsRef, cloneObject(shallowFieldsStateRef.current), shouldUnregister));\n  }\n\n  const validateResolver = useCallback(async function () {\n    let values = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const newDefaultValues = isEmptyObject(fieldsRef.current) ? defaultValuesRef.current : {};\n    const {\n      errors\n    } = (await resolverRef.current(Object.assign(Object.assign(Object.assign({}, newDefaultValues), getValues()), values), contextRef.current, isValidateAllFieldCriteria)) || {};\n    const isValid = isEmptyObject(errors);\n    formStateRef.current.isValid !== isValid && updateFormState({\n      isValid\n    });\n  }, [isValidateAllFieldCriteria]);\n  const removeFieldEventListener = useCallback((field, forceDelete) => {\n    findRemovedFieldAndRemoveListener(fieldsRef, handleChangeRef.current, field, shallowFieldsStateRef, shouldUnregister, forceDelete);\n\n    if (shouldUnregister) {\n      unset(validFieldsRef.current, field.ref.name);\n      unset(fieldsWithValidationRef.current, field.ref.name);\n    }\n  }, [shouldUnregister]);\n  const updateWatchedValue = useCallback(name => {\n    if (isWatchAllRef.current) {\n      updateFormState();\n    } else {\n      for (const watchField of watchFieldsRef.current) {\n        if (watchField.startsWith(name)) {\n          updateFormState();\n          break;\n        }\n      }\n\n      renderWatchedInputs(name);\n    }\n  }, []);\n  const removeFieldEventListenerAndRef = useCallback((field, forceDelete) => {\n    if (field) {\n      removeFieldEventListener(field, forceDelete);\n\n      if (shouldUnregister && !compact(field.options || []).length) {\n        unset(formStateRef.current.errors, field.ref.name);\n        set(formStateRef.current.dirtyFields, field.ref.name, true);\n        updateFormState({\n          isDirty: isFormDirty()\n        });\n        readFormStateRef.current.isValid && resolverRef.current && validateResolver();\n        updateWatchedValue(field.ref.name);\n      }\n    }\n  }, [validateResolver, removeFieldEventListener]);\n\n  function clearErrors(name) {\n    name && (Array.isArray(name) ? name : [name]).forEach(inputName => fieldsRef.current[inputName] && isKey(inputName) ? delete formStateRef.current.errors[inputName] : unset(formStateRef.current.errors, inputName));\n    updateFormState({\n      errors: name ? formStateRef.current.errors : {}\n    });\n  }\n\n  function setError(name, error) {\n    const ref = (fieldsRef.current[name] || {}).ref;\n    set(formStateRef.current.errors, name, Object.assign(Object.assign({}, error), {\n      ref\n    }));\n    updateFormState({\n      isValid: false\n    });\n    error.shouldFocus && ref && ref.focus && ref.focus();\n  }\n\n  const watchInternal = useCallback((fieldNames, defaultValue, watchId) => {\n    const watchFields = watchId ? useWatchFieldsRef.current[watchId] : watchFieldsRef.current;\n    let fieldValues = getFieldsValues(fieldsRef, cloneObject(shallowFieldsStateRef.current), shouldUnregister, false, fieldNames);\n\n    if (isString(fieldNames)) {\n      const parentNodeName = getFieldArrayParentName(fieldNames) || fieldNames;\n\n      if (fieldArrayNamesRef.current.has(parentNodeName)) {\n        fieldValues = Object.assign(Object.assign({}, fieldArrayValuesRef.current), fieldValues);\n      }\n\n      return assignWatchFields(fieldValues, fieldNames, watchFields, isUndefined(get(defaultValuesRef.current, fieldNames)) ? defaultValue : get(defaultValuesRef.current, fieldNames), true);\n    }\n\n    const combinedDefaultValues = isUndefined(defaultValue) ? defaultValuesRef.current : defaultValue;\n\n    if (Array.isArray(fieldNames)) {\n      return fieldNames.reduce((previous, name) => Object.assign(Object.assign({}, previous), {\n        [name]: assignWatchFields(fieldValues, name, watchFields, combinedDefaultValues)\n      }), {});\n    }\n\n    isWatchAllRef.current = isUndefined(watchId);\n    return transformToNestObject(!isEmptyObject(fieldValues) && fieldValues || combinedDefaultValues);\n  }, []);\n\n  function watch(fieldNames, defaultValue) {\n    return watchInternal(fieldNames, defaultValue);\n  }\n\n  function unregister(name) {\n    for (const fieldName of Array.isArray(name) ? name : [name]) {\n      removeFieldEventListenerAndRef(fieldsRef.current[fieldName], true);\n    }\n  }\n\n  function registerFieldRef(ref) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (!ref.name) {\n        return console.warn('📋 Field is missing `name` attribute', ref, `https://react-hook-form.com/api#useForm`);\n      }\n\n      if (fieldArrayNamesRef.current.has(ref.name.split(/\\[\\d+\\]$/)[0]) && !RegExp(`^${ref.name.split(/\\[\\d+\\]$/)[0]}[\\\\d+].\\\\w+`.replace(/\\[/g, '\\\\[').replace(/\\]/g, '\\\\]')).test(ref.name)) {\n        return console.warn('📋 `name` prop should be in object shape: name=\"test[index].name\"', ref, 'https://react-hook-form.com/api#useFieldArray');\n      }\n    }\n\n    const {\n      name,\n      type,\n      value\n    } = ref;\n    const fieldRefAndValidationOptions = Object.assign({\n      ref\n    }, options);\n    const fields = fieldsRef.current;\n    const isRadioOrCheckbox = isRadioOrCheckboxFunction(ref);\n    const isFieldArray = isNameInFieldArray(fieldArrayNamesRef.current, name);\n\n    const compareRef = currentRef => isWeb && (!isHTMLElement(ref) || currentRef === ref);\n\n    let field = fields[name];\n    let isEmptyDefaultValue = true;\n    let defaultValue;\n\n    if (field && (isRadioOrCheckbox ? Array.isArray(field.options) && compact(field.options).find(option => {\n      return value === option.ref.value && compareRef(option.ref);\n    }) : compareRef(field.ref))) {\n      fields[name] = Object.assign(Object.assign({}, field), options);\n      return;\n    }\n\n    if (type) {\n      field = isRadioOrCheckbox ? Object.assign({\n        options: [...compact(field && field.options || []), {\n          ref\n        }],\n        ref: {\n          type,\n          name\n        }\n      }, options) : Object.assign({}, fieldRefAndValidationOptions);\n    } else {\n      field = fieldRefAndValidationOptions;\n    }\n\n    fields[name] = field;\n    const isEmptyUnmountFields = isUndefined(get(shallowFieldsStateRef.current, name));\n\n    if (!isEmptyObject(defaultValuesRef.current) || !isEmptyUnmountFields) {\n      defaultValue = get(isEmptyUnmountFields ? defaultValuesRef.current : shallowFieldsStateRef.current, name);\n      isEmptyDefaultValue = isUndefined(defaultValue);\n\n      if (!isEmptyDefaultValue && !isFieldArray) {\n        setFieldValue(name, defaultValue);\n      }\n    }\n\n    if (!isEmptyObject(options)) {\n      set(fieldsWithValidationRef.current, name, true);\n\n      if (!isOnSubmit && readFormStateRef.current.isValid) {\n        validateField(fieldsRef, isValidateAllFieldCriteria, field, shallowFieldsStateRef).then(error => {\n          const previousFormIsValid = formStateRef.current.isValid;\n          isEmptyObject(error) ? set(validFieldsRef.current, name, true) : unset(validFieldsRef.current, name);\n          previousFormIsValid !== isEmptyObject(error) && updateFormState();\n        });\n      }\n    }\n\n    if (shouldUnregister && !(isFieldArray && isEmptyDefaultValue)) {\n      !isFieldArray && unset(formStateRef.current.dirtyFields, name);\n    }\n\n    if (type) {\n      attachEventListeners(isRadioOrCheckbox && field.options ? field.options[field.options.length - 1] : field, isRadioOrCheckbox || isSelectInput(ref), handleChangeRef.current);\n    }\n  }\n\n  function register(refOrRegisterOptions, options) {\n    if (!isWindowUndefined) {\n      if (isString(refOrRegisterOptions)) {\n        registerFieldRef({\n          name: refOrRegisterOptions\n        }, options);\n      } else if (isObject(refOrRegisterOptions) && 'name' in refOrRegisterOptions) {\n        registerFieldRef(refOrRegisterOptions, options);\n      } else {\n        return ref => ref && registerFieldRef(ref, refOrRegisterOptions);\n      }\n    }\n  }\n\n  const handleSubmit = useCallback((onValid, onInvalid) => async e => {\n    if (e && e.preventDefault) {\n      e.preventDefault();\n      e.persist();\n    }\n\n    let fieldErrors = {};\n    let fieldValues = setFieldArrayDefaultValues(getFieldsValues(fieldsRef, cloneObject(shallowFieldsStateRef.current), shouldUnregister, true));\n    readFormStateRef.current.isSubmitting && updateFormState({\n      isSubmitting: true\n    });\n\n    try {\n      if (resolverRef.current) {\n        const {\n          errors,\n          values\n        } = await resolverRef.current(fieldValues, contextRef.current, isValidateAllFieldCriteria);\n        formStateRef.current.errors = fieldErrors = errors;\n        fieldValues = values;\n      } else {\n        for (const field of Object.values(fieldsRef.current)) {\n          if (field) {\n            const {\n              name\n            } = field.ref;\n            const fieldError = await validateField(fieldsRef, isValidateAllFieldCriteria, field, shallowFieldsStateRef);\n\n            if (fieldError[name]) {\n              set(fieldErrors, name, fieldError[name]);\n              unset(validFieldsRef.current, name);\n            } else if (get(fieldsWithValidationRef.current, name)) {\n              unset(formStateRef.current.errors, name);\n              set(validFieldsRef.current, name, true);\n            }\n          }\n        }\n      }\n\n      if (isEmptyObject(fieldErrors) && Object.keys(formStateRef.current.errors).every(name => name in fieldsRef.current)) {\n        updateFormState({\n          errors: {},\n          isSubmitting: true\n        });\n        await onValid(fieldValues, e);\n      } else {\n        formStateRef.current.errors = Object.assign(Object.assign({}, formStateRef.current.errors), fieldErrors);\n        onInvalid && (await onInvalid(formStateRef.current.errors, e));\n        shouldFocusError && focusOnErrorField(fieldsRef.current, formStateRef.current.errors);\n      }\n    } finally {\n      formStateRef.current.isSubmitting = false;\n      updateFormState({\n        isSubmitted: true,\n        isSubmitting: false,\n        isSubmitSuccessful: isEmptyObject(formStateRef.current.errors),\n        submitCount: formStateRef.current.submitCount + 1\n      });\n    }\n  }, [shouldFocusError, isValidateAllFieldCriteria]);\n\n  const resetRefs = _ref12 => {\n    let {\n      errors,\n      isDirty,\n      isSubmitted,\n      touched,\n      isValid,\n      submitCount,\n      dirtyFields\n    } = _ref12;\n\n    if (!isValid) {\n      validFieldsRef.current = {};\n      fieldsWithValidationRef.current = {};\n    }\n\n    fieldArrayDefaultValuesRef.current = {};\n    watchFieldsRef.current = new Set();\n    isWatchAllRef.current = false;\n    updateFormState({\n      submitCount: submitCount ? formStateRef.current.submitCount : 0,\n      isDirty: isDirty ? formStateRef.current.isDirty : false,\n      isSubmitted: isSubmitted ? formStateRef.current.isSubmitted : false,\n      isValid: isValid ? formStateRef.current.isValid : false,\n      dirtyFields: dirtyFields ? formStateRef.current.dirtyFields : {},\n      touched: touched ? formStateRef.current.touched : {},\n      errors: errors ? formStateRef.current.errors : {},\n      isSubmitting: false,\n      isSubmitSuccessful: false\n    });\n  };\n\n  const reset = function (values) {\n    let omitResetState = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (isWeb) {\n      for (const field of Object.values(fieldsRef.current)) {\n        if (field) {\n          const {\n            ref,\n            options\n          } = field;\n          const inputRef = isRadioOrCheckboxFunction(ref) && Array.isArray(options) ? options[0].ref : ref;\n\n          if (isHTMLElement(inputRef)) {\n            try {\n              inputRef.closest('form').reset();\n              break;\n            } catch (_a) {}\n          }\n        }\n      }\n    }\n\n    fieldsRef.current = {};\n    defaultValuesRef.current = Object.assign({}, values || defaultValuesRef.current);\n    values && renderWatchedInputs('');\n    Object.values(resetFieldArrayFunctionRef.current).forEach(resetFieldArray => isFunction(resetFieldArray) && resetFieldArray());\n    shallowFieldsStateRef.current = shouldUnregister ? {} : cloneObject(values || defaultValuesRef.current);\n    resetRefs(omitResetState);\n  };\n\n  useEffect(() => {\n    resolver && readFormStateRef.current.isValid && validateResolver();\n    observerRef.current = observerRef.current || !isWeb ? observerRef.current : onDomRemove(fieldsRef, removeFieldEventListenerAndRef);\n  }, [removeFieldEventListenerAndRef, defaultValuesRef.current]);\n  useEffect(() => () => {\n    observerRef.current && observerRef.current.disconnect();\n    isUnMount.current = true;\n\n    if (process.env.NODE_ENV !== 'production') {\n      return;\n    }\n\n    Object.values(fieldsRef.current).forEach(field => removeFieldEventListenerAndRef(field, true));\n  }, []);\n\n  if (!resolver && readFormStateRef.current.isValid) {\n    formState.isValid = deepEqual(validFieldsRef.current, fieldsWithValidationRef.current) && isEmptyObject(formStateRef.current.errors);\n  }\n\n  const commonProps = {\n    trigger,\n    setValue: useCallback(setValue, [setInternalValue, trigger]),\n    getValues: useCallback(getValues, []),\n    register: useCallback(register, [defaultValuesRef.current]),\n    unregister: useCallback(unregister, []),\n    formState: isProxyEnabled ? new Proxy(formState, {\n      get: (obj, prop) => {\n        if (process.env.NODE_ENV !== 'production') {\n          if (prop === 'isValid' && isOnSubmit) {\n            console.warn('📋 `formState.isValid` is applicable with `onTouched`, `onChange` or `onBlur` mode. https://react-hook-form.com/api#formState');\n          }\n        }\n\n        if (prop in obj) {\n          readFormStateRef.current[prop] = true;\n          return obj[prop];\n        }\n\n        return undefined;\n      }\n    }) : formState\n  };\n  const control = useMemo(() => Object.assign({\n    isFormDirty,\n    updateWatchedValue,\n    shouldUnregister,\n    updateFormState,\n    removeFieldEventListener,\n    watchInternal,\n    mode: modeRef.current,\n    reValidateMode: {\n      isReValidateOnBlur,\n      isReValidateOnChange\n    },\n    validateResolver: resolver ? validateResolver : undefined,\n    fieldsRef,\n    resetFieldArrayFunctionRef,\n    useWatchFieldsRef,\n    useWatchRenderFunctionsRef,\n    fieldArrayDefaultValuesRef,\n    validFieldsRef,\n    fieldsWithValidationRef,\n    fieldArrayNamesRef,\n    readFormStateRef,\n    formStateRef,\n    defaultValuesRef,\n    shallowFieldsStateRef,\n    fieldArrayValuesRef\n  }, commonProps), [defaultValuesRef.current, updateWatchedValue, shouldUnregister, removeFieldEventListener, watchInternal]);\n  return Object.assign({\n    watch,\n    control,\n    handleSubmit,\n    reset: useCallback(reset, []),\n    clearErrors: useCallback(clearErrors, []),\n    setError: useCallback(setError, []),\n    errors: formState.errors\n  }, commonProps);\n}\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\n\n\nfunction __rest(s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n}\n\nconst FormContext = createContext(null);\nFormContext.displayName = 'RHFContext';\n\nconst useFormContext = () => useContext(FormContext);\n\nconst FormProvider = _a => {\n  var {\n    children\n  } = _a,\n      props = __rest(_a, [\"children\"]);\n\n  return createElement(FormContext.Provider, {\n    value: Object.assign({}, props)\n  }, children);\n};\n\nvar generateId = () => {\n  const d = typeof performance === UNDEFINED ? Date.now() : performance.now() * 1000;\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {\n    const r = (Math.random() * 16 + d) % 16 | 0;\n    return (c == 'x' ? r : r & 0x3 | 0x8).toString(16);\n  });\n};\n\nfunction removeAtIndexes(data, indexes) {\n  let i = 0;\n  const temp = [...data];\n\n  for (const index of indexes) {\n    temp.splice(index - i, 1);\n    i++;\n  }\n\n  return compact(temp).length ? temp : [];\n}\n\nvar removeArrayAt = (data, index) => isUndefined(index) ? [] : removeAtIndexes(data, (Array.isArray(index) ? index : [index]).sort());\n\nvar moveArrayAt = (data, from, to) => {\n  if (Array.isArray(data)) {\n    if (isUndefined(data[to])) {\n      data[to] = undefined;\n    }\n\n    data.splice(to, 0, data.splice(from, 1)[0]);\n    return data;\n  }\n\n  return [];\n};\n\nvar swapArrayAt = (data, indexA, indexB) => {\n  const temp = [data[indexB], data[indexA]];\n  data[indexA] = temp[0];\n  data[indexB] = temp[1];\n};\n\nfunction prepend(data, value) {\n  return [...(Array.isArray(value) ? value : [value || undefined]), ...data];\n}\n\nfunction insert(data, index, value) {\n  return [...data.slice(0, index), ...(Array.isArray(value) ? value : [value || undefined]), ...data.slice(index)];\n}\n\nvar fillEmptyArray = value => Array.isArray(value) ? Array(value.length).fill(undefined) : undefined;\n\nvar fillBooleanArray = value => (Array.isArray(value) ? value : [value]).map(data => {\n  if (isObject(data)) {\n    const object = {};\n\n    for (const key in data) {\n      object[key] = true;\n    }\n\n    return object;\n  }\n\n  return true;\n});\n\nconst mapIds = function () {\n  let values = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  let keyName = arguments.length > 1 ? arguments[1] : undefined;\n  let skipWarn = arguments.length > 2 ? arguments[2] : undefined;\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (!skipWarn) {\n      for (const value of values) {\n        if (typeof value === 'object') {\n          if (keyName in value) {\n            console.warn(`📋 useFieldArray fieldValues contain the keyName \\`${keyName}\\` which is reserved for use by useFieldArray. https://react-hook-form.com/api#useFieldArray`);\n            break;\n          }\n        } else {\n          console.warn(`📋 useFieldArray input's name should be in object shape instead of flat array. https://react-hook-form.com/api#useFieldArray`);\n          break;\n        }\n      }\n    }\n  }\n\n  return values.map(value => Object.assign({\n    [keyName]: value[keyName] || generateId()\n  }, value));\n};\n\nconst useFieldArray = _ref13 => {\n  let {\n    control,\n    name,\n    keyName = 'id'\n  } = _ref13;\n  const methods = useFormContext();\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (!control && !methods) {\n      throw new Error('📋 useFieldArray is missing `control` prop. https://react-hook-form.com/api#useFieldArray');\n    }\n  }\n\n  const focusIndexRef = useRef(-1);\n  const isUnMount = useRef(false);\n  const {\n    isFormDirty,\n    updateWatchedValue,\n    resetFieldArrayFunctionRef,\n    fieldArrayNamesRef,\n    fieldsRef,\n    defaultValuesRef,\n    removeFieldEventListener,\n    formStateRef,\n    shallowFieldsStateRef,\n    updateFormState,\n    readFormStateRef,\n    validFieldsRef,\n    fieldsWithValidationRef,\n    fieldArrayDefaultValuesRef,\n    validateResolver,\n    getValues,\n    shouldUnregister,\n    fieldArrayValuesRef\n  } = control || methods.control;\n\n  const getDefaultValues = values => get(shouldUnregister ? values : shallowFieldsStateRef.current, name, []);\n\n  const fieldArrayParentName = getFieldArrayParentName(name);\n  const memoizedDefaultValues = useRef([...(get(fieldArrayDefaultValuesRef.current, fieldArrayParentName) ? getDefaultValues(fieldArrayDefaultValuesRef.current) : getDefaultValues(defaultValuesRef.current))]);\n  const [fields, setFields] = useState(mapIds(memoizedDefaultValues.current, keyName));\n  set(fieldArrayValuesRef.current, name, fields);\n\n  const omitKey = fields => fields.map(function () {\n    let _a = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    var _b = keyName,\n        omitted = _a[_b],\n        rest = __rest(_a, [typeof _b === \"symbol\" ? _b : _b + \"\"]);\n\n    return rest;\n  });\n\n  fieldArrayNamesRef.current.add(name);\n  const getFieldArrayValue = useCallback(() => get(fieldArrayValuesRef.current, name, []), [name]);\n\n  const getCurrentFieldsValues = () => mapIds(get(getValues(), name, getFieldArrayValue()).map((item, index) => Object.assign(Object.assign({}, getFieldArrayValue()[index]), item)), keyName, true);\n\n  fieldArrayNamesRef.current.add(name);\n\n  if (fieldArrayParentName && !get(fieldArrayDefaultValuesRef.current, fieldArrayParentName)) {\n    set(fieldArrayDefaultValuesRef.current, fieldArrayParentName, cloneObject(get(defaultValuesRef.current, fieldArrayParentName)));\n  }\n\n  const setFieldAndValidState = fieldsValues => {\n    setFields(fieldsValues);\n    set(fieldArrayValuesRef.current, name, fieldsValues);\n\n    if (readFormStateRef.current.isValid && validateResolver) {\n      const values = getValues();\n      set(values, name, fieldsValues);\n      validateResolver(values);\n    }\n  };\n\n  const resetFields = () => {\n    for (const key in fieldsRef.current) {\n      if (isMatchFieldArrayName(key, name)) {\n        removeFieldEventListener(fieldsRef.current[key], true);\n        delete fieldsRef.current[key];\n      }\n    }\n  };\n\n  const cleanup = ref => !compact(get(ref, name, [])).length && unset(ref, name);\n\n  const updateDirtyFieldsWithDefaultValues = updatedFieldArrayValues => {\n    if (updatedFieldArrayValues) {\n      set(formStateRef.current.dirtyFields, name, setFieldArrayDirtyFields(omitKey(updatedFieldArrayValues), get(defaultValuesRef.current, name, []), get(formStateRef.current.dirtyFields, name, [])));\n    }\n  };\n\n  const batchStateUpdate = function (method, args, updatedFieldValues) {\n    let updatedFormValues = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n    let shouldSet = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n    let shouldUpdateValid = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n\n    if (get(shallowFieldsStateRef.current, name)) {\n      const output = method(get(shallowFieldsStateRef.current, name), args.argA, args.argB);\n      shouldSet && set(shallowFieldsStateRef.current, name, output);\n    }\n\n    if (get(fieldArrayDefaultValuesRef.current, name)) {\n      const output = method(get(fieldArrayDefaultValuesRef.current, name), args.argA, args.argB);\n      shouldSet && set(fieldArrayDefaultValuesRef.current, name, output);\n    }\n\n    if (Array.isArray(get(formStateRef.current.errors, name))) {\n      const output = method(get(formStateRef.current.errors, name), args.argA, args.argB);\n      shouldSet && set(formStateRef.current.errors, name, output);\n      cleanup(formStateRef.current.errors);\n    }\n\n    if (readFormStateRef.current.touched && get(formStateRef.current.touched, name)) {\n      const output = method(get(formStateRef.current.touched, name), args.argA, args.argB);\n      shouldSet && set(formStateRef.current.touched, name, output);\n      cleanup(formStateRef.current.touched);\n    }\n\n    if (readFormStateRef.current.dirtyFields || readFormStateRef.current.isDirty) {\n      set(formStateRef.current.dirtyFields, name, setFieldArrayDirtyFields(omitKey(updatedFormValues), get(defaultValuesRef.current, name, []), get(formStateRef.current.dirtyFields, name, [])));\n      updateDirtyFieldsWithDefaultValues(updatedFieldValues);\n      cleanup(formStateRef.current.dirtyFields);\n    }\n\n    if (shouldUpdateValid && readFormStateRef.current.isValid && !validateResolver) {\n      set(validFieldsRef.current, name, method(get(validFieldsRef.current, name, []), args.argA));\n      cleanup(validFieldsRef.current);\n      set(fieldsWithValidationRef.current, name, method(get(fieldsWithValidationRef.current, name, []), args.argA));\n      cleanup(fieldsWithValidationRef.current);\n    }\n\n    if (!isUnMount.current && readFormStateRef.current.isDirty) {\n      updateFormState({\n        isDirty: isFormDirty(name, omitKey(updatedFormValues))\n      });\n    }\n  };\n\n  const append = function (value) {\n    let shouldFocus = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    const appendValue = Array.isArray(value) ? value : [value];\n    const updateFormValues = [...getCurrentFieldsValues(), ...mapIds(appendValue, keyName)];\n    setFieldAndValidState(updateFormValues);\n\n    if (readFormStateRef.current.dirtyFields || readFormStateRef.current.isDirty) {\n      updateDirtyFieldsWithDefaultValues(updateFormValues);\n      updateFormState({\n        isDirty: true,\n        dirtyFields: formStateRef.current.dirtyFields\n      });\n    }\n\n    !shouldUnregister && set(shallowFieldsStateRef.current, name, [...(get(shallowFieldsStateRef.current, name) || []), ...cloneObject(appendValue)]);\n    focusIndexRef.current = shouldFocus ? get(fieldArrayValuesRef.current, name).length - 1 : -1;\n  };\n\n  const prepend$1 = function (value) {\n    let shouldFocus = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    const emptyArray = fillEmptyArray(value);\n    const updatedFieldArrayValues = prepend(getCurrentFieldsValues(), mapIds(Array.isArray(value) ? value : [value], keyName));\n    setFieldAndValidState(updatedFieldArrayValues);\n    resetFields();\n    batchStateUpdate(prepend, {\n      argA: emptyArray,\n      argC: fillBooleanArray(value)\n    }, updatedFieldArrayValues);\n    focusIndexRef.current = shouldFocus ? 0 : -1;\n  };\n\n  const remove = index => {\n    const fieldValues = getCurrentFieldsValues();\n    const updatedFieldValues = removeArrayAt(fieldValues, index);\n    setFieldAndValidState(updatedFieldValues);\n    resetFields();\n    batchStateUpdate(removeArrayAt, {\n      argA: index,\n      argC: index\n    }, updatedFieldValues, removeArrayAt(fieldValues, index), true, true);\n  };\n\n  const insert$1 = function (index, value) {\n    let shouldFocus = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    const emptyArray = fillEmptyArray(value);\n    const fieldValues = getCurrentFieldsValues();\n    const updatedFieldArrayValues = insert(fieldValues, index, mapIds(Array.isArray(value) ? value : [value], keyName));\n    setFieldAndValidState(updatedFieldArrayValues);\n    resetFields();\n    batchStateUpdate(insert, {\n      argA: index,\n      argB: emptyArray,\n      argC: index,\n      argD: fillBooleanArray(value)\n    }, updatedFieldArrayValues, insert(fieldValues, index));\n    focusIndexRef.current = shouldFocus ? index : -1;\n  };\n\n  const swap = (indexA, indexB) => {\n    const fieldValues = getCurrentFieldsValues();\n    swapArrayAt(fieldValues, indexA, indexB);\n    resetFields();\n    setFieldAndValidState([...fieldValues]);\n    batchStateUpdate(swapArrayAt, {\n      argA: indexA,\n      argB: indexB,\n      argC: indexA,\n      argD: indexB\n    }, undefined, fieldValues, false);\n  };\n\n  const move = (from, to) => {\n    const fieldValues = getCurrentFieldsValues();\n    moveArrayAt(fieldValues, from, to);\n    resetFields();\n    setFieldAndValidState([...fieldValues]);\n    batchStateUpdate(moveArrayAt, {\n      argA: from,\n      argB: to,\n      argC: from,\n      argD: to\n    }, undefined, fieldValues, false);\n  };\n\n  useEffect(() => {\n    if (process.env.NODE_ENV !== 'production') {\n      if (!name) {\n        console.warn('📋 useFieldArray is missing `name` attribute. https://react-hook-form.com/api#useFieldArray');\n      }\n    }\n\n    const defaultValues = get(fieldArrayDefaultValuesRef.current, name);\n\n    if (defaultValues && fields.length < defaultValues.length) {\n      set(fieldArrayDefaultValuesRef.current, name, defaultValues.slice(1));\n    }\n\n    updateWatchedValue(name);\n\n    if (focusIndexRef.current > -1) {\n      for (const key in fieldsRef.current) {\n        const field = fieldsRef.current[key];\n\n        if (key.startsWith(`${name}[${focusIndexRef.current}]`) && field.ref.focus) {\n          field.ref.focus();\n          break;\n        }\n      }\n    }\n\n    focusIndexRef.current = -1;\n  }, [fields, name]);\n  useEffect(() => {\n    const resetFunctions = resetFieldArrayFunctionRef.current;\n    const fieldArrayNames = fieldArrayNamesRef.current;\n\n    if (!getFieldArrayParentName(name)) {\n      resetFunctions[name] = data => {\n        resetFields();\n        !data && unset(fieldArrayDefaultValuesRef.current, name);\n        unset(shallowFieldsStateRef.current, name);\n        memoizedDefaultValues.current = get(data || defaultValuesRef.current, name);\n\n        if (!isUnMount.current) {\n          setFields(mapIds(memoizedDefaultValues.current, keyName));\n        }\n      };\n    }\n\n    return () => {\n      isUnMount.current = true;\n      shouldUnregister && remove();\n      resetFields();\n      delete resetFunctions[name];\n      unset(fieldArrayValuesRef.current, name);\n      fieldArrayNames.delete(name);\n    };\n  }, []);\n  return {\n    swap: useCallback(swap, [name]),\n    move: useCallback(move, [name]),\n    prepend: useCallback(prepend$1, [name]),\n    append: useCallback(append, [name]),\n    remove: useCallback(remove, [name]),\n    insert: useCallback(insert$1, [name]),\n    fields\n  };\n};\n\nvar getInputValue = event => isPrimitive(event) || !isObject(event.target) || isObject(event.target) && !event.type ? event : isUndefined(event.target.value) ? event.target.checked : event.target.value;\n\nfunction useController(_ref14) {\n  let {\n    name,\n    rules,\n    defaultValue,\n    control,\n    onFocus\n  } = _ref14;\n  const methods = useFormContext();\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (!control && !methods) {\n      throw new Error('📋 Controller is missing `control` prop. https://react-hook-form.com/api#Controller');\n    }\n  }\n\n  const {\n    defaultValuesRef,\n    setValue,\n    register,\n    unregister,\n    trigger,\n    mode,\n    reValidateMode: {\n      isReValidateOnBlur,\n      isReValidateOnChange\n    },\n    formState,\n    formStateRef: {\n      current: {\n        isSubmitted,\n        touched,\n        errors\n      }\n    },\n    updateFormState,\n    readFormStateRef,\n    fieldsRef,\n    fieldArrayNamesRef,\n    shallowFieldsStateRef\n  } = control || methods.control;\n  const isNotFieldArray = !isNameInFieldArray(fieldArrayNamesRef.current, name);\n\n  const getInitialValue = () => !isUndefined(get(shallowFieldsStateRef.current, name)) && isNotFieldArray ? get(shallowFieldsStateRef.current, name) : isUndefined(defaultValue) ? get(defaultValuesRef.current, name) : defaultValue;\n\n  const [value, setInputStateValue] = useState(getInitialValue());\n  const valueRef = useRef(value);\n  const ref = useRef({\n    focus: () => null\n  });\n  const onFocusRef = useRef(onFocus || (() => {\n    if (isFunction(ref.current.focus)) {\n      ref.current.focus();\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (!isFunction(ref.current.focus)) {\n        console.warn(`📋 'ref' from Controller render prop must be attached to a React component or a DOM Element whose ref provides a 'focus()' method`);\n      }\n    }\n  }));\n  const shouldValidate = useCallback(isBlurEvent => !skipValidation(Object.assign({\n    isBlurEvent,\n    isReValidateOnBlur,\n    isReValidateOnChange,\n    isSubmitted,\n    isTouched: !!get(touched, name)\n  }, mode)), [isReValidateOnBlur, isReValidateOnChange, isSubmitted, touched, name, mode]);\n  const commonTask = useCallback(_ref15 => {\n    let [event] = _ref15;\n    const data = getInputValue(event);\n    setInputStateValue(data);\n    valueRef.current = data;\n    return data;\n  }, []);\n  const registerField = useCallback(shouldUpdateValue => {\n    if (process.env.NODE_ENV !== 'production') {\n      if (!name) {\n        return console.warn('📋 Field is missing `name` prop. https://react-hook-form.com/api#Controller');\n      }\n    }\n\n    if (fieldsRef.current[name]) {\n      fieldsRef.current[name] = Object.assign({\n        ref: fieldsRef.current[name].ref\n      }, rules);\n    } else {\n      register(Object.defineProperties({\n        name,\n        focus: onFocusRef.current\n      }, {\n        value: {\n          set(data) {\n            setInputStateValue(data);\n            valueRef.current = data;\n          },\n\n          get() {\n            return valueRef.current;\n          }\n\n        }\n      }), rules);\n      shouldUpdateValue = isUndefined(get(defaultValuesRef.current, name));\n    }\n\n    shouldUpdateValue && isNotFieldArray && setInputStateValue(getInitialValue());\n  }, [rules, name, register]);\n  useEffect(() => () => unregister(name), [name]);\n  useEffect(() => {\n    if (process.env.NODE_ENV !== 'production') {\n      if (isUndefined(value)) {\n        console.warn(`📋 ${name} is missing in the 'defaultValue' prop of either its Controller (https://react-hook-form.com/api#Controller) or useForm (https://react-hook-form.com/api#useForm)`);\n      }\n\n      if (!isNotFieldArray && isUndefined(defaultValue)) {\n        console.warn('📋 Controller is missing `defaultValue` prop when using `useFieldArray`. https://react-hook-form.com/api#Controller');\n      }\n    }\n\n    registerField();\n  }, [registerField]);\n  useEffect(() => {\n    !fieldsRef.current[name] && registerField(true);\n  });\n  const onBlur = useCallback(() => {\n    if (readFormStateRef.current.touched && !get(touched, name)) {\n      set(touched, name, true);\n      updateFormState({\n        touched\n      });\n    }\n\n    shouldValidate(true) && trigger(name);\n  }, [name, updateFormState, shouldValidate, trigger, readFormStateRef]);\n  const onChange = useCallback(function () {\n    for (var _len = arguments.length, event = new Array(_len), _key = 0; _key < _len; _key++) {\n      event[_key] = arguments[_key];\n    }\n\n    return setValue(name, commonTask(event), {\n      shouldValidate: shouldValidate(),\n      shouldDirty: true\n    });\n  }, [setValue, name, shouldValidate]);\n  return {\n    field: {\n      onChange,\n      onBlur,\n      name,\n      value,\n      ref\n    },\n    meta: Object.defineProperties({\n      invalid: !!get(errors, name)\n    }, {\n      isDirty: {\n        get() {\n          return !!get(formState.dirtyFields, name);\n        }\n\n      },\n      isTouched: {\n        get() {\n          return !!get(formState.touched, name);\n        }\n\n      }\n    })\n  };\n}\n\nfunction useWatch(_ref16) {\n  let {\n    control,\n    name,\n    defaultValue\n  } = _ref16;\n  const methods = useFormContext();\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (!control && !methods) {\n      throw new Error('📋 useWatch is missing `control` prop. https://react-hook-form.com/api#useWatch');\n    }\n  }\n\n  const {\n    useWatchFieldsRef,\n    useWatchRenderFunctionsRef,\n    watchInternal,\n    defaultValuesRef\n  } = control || methods.control;\n  const updateValue = useState()[1];\n  const idRef = useRef();\n  const defaultValueRef = useRef(defaultValue);\n  useEffect(() => {\n    if (process.env.NODE_ENV !== 'production') {\n      if (name === '') {\n        console.warn('📋 useWatch is missing `name` attribute. https://react-hook-form.com/api#useWatch');\n      }\n    }\n\n    const id = idRef.current = generateId();\n    const watchFieldsHookRender = useWatchRenderFunctionsRef.current;\n    const watchFieldsHook = useWatchFieldsRef.current;\n    watchFieldsHook[id] = new Set();\n\n    watchFieldsHookRender[id] = () => updateValue({});\n\n    watchInternal(name, defaultValueRef.current, id);\n    return () => {\n      delete watchFieldsHook[id];\n      delete watchFieldsHookRender[id];\n    };\n  }, [name, useWatchRenderFunctionsRef, useWatchFieldsRef, watchInternal, defaultValueRef]);\n  return idRef.current ? watchInternal(name, defaultValueRef.current, idRef.current) : isUndefined(defaultValue) ? isString(name) ? get(defaultValuesRef.current, name) : Array.isArray(name) ? name.reduce((previous, inputName) => Object.assign(Object.assign({}, previous), {\n    [inputName]: get(defaultValuesRef.current, inputName)\n  }), {}) : defaultValuesRef.current : defaultValue;\n}\n\nconst Controller = props => {\n  const {\n    rules,\n    as,\n    render,\n    defaultValue,\n    control,\n    onFocus\n  } = props,\n        rest = __rest(props, [\"rules\", \"as\", \"render\", \"defaultValue\", \"control\", \"onFocus\"]);\n\n  const {\n    field,\n    meta\n  } = useController(props);\n  const componentProps = Object.assign(Object.assign({}, rest), field);\n  return as ? isValidElement(as) ? cloneElement(as, componentProps) : createElement(as, componentProps) : render ? render(field, meta) : null;\n};\n\nexport { Controller, FormProvider, appendErrors, get, transformToNestObject, useController, useFieldArray, useForm, useFormContext, useWatch };","map":{"version":3,"mappings":"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","names":["value","HTMLElement","EVENTS","BLUR","CHANGE","INPUT","VALIDATION_MODE","onBlur","onChange","onSubmit","onTouched","all","SELECT","UNDEFINED","INPUT_VALIDATION_RULES","max","min","maxLength","minLength","pattern","required","validate","attachEventListeners","shouldAttachChangeEvent","handleChange","ref","isHTMLElement","addEventListener","isObjectType","isNullOrUndefined","Array","isArray","Date","test","filter","Boolean","input","compact","replace","split","set","object","path","index","tempPath","isKey","stringToPath","length","lastIndex","key","newValue","objValue","isObject","isNaN","data","val","undefined","obj","defaultValue","result","reduce","isUndefined","fields","fieldErrors","get","field","focus","options","validateWithStateUpdate","removeEventListener","defaultReturn","isValid","previous","option","checked","selected","map","element","type","defaultResult","validResult","values","attributes","getFieldValue","fieldsRef","name","shallowFieldsStateRef","excludeDisabled","shouldKeepRawValue","current","disabled","valueAsNumber","valueAsDate","setValueAs","isFileInput","files","isRadioInput","getRadioValue","isMultipleSelect","getMultipleSelectValue","isCheckBox","getCheckboxValue","NaN","isDetached","nodeType","Node","DOCUMENT_NODE","parentNode","Object","keys","baseGet","updatePath","slice","unset","childObject","previousObjRef","k","objectRef","currentPaths","currentPathsLength","item","isEmptyObject","isBoolean","isSameRef","fieldValue","findRemovedFieldAndRemoveListener","shouldUnregister","forceDelete","fieldRef","isCheckBoxInput","forEach","removeAllEventListeners","deepMerge","target","source","isPrimitive","targetValue","sourceValue","deepEqual","object1","object2","isErrorObject","React.isValidElement","keys1","keys2","val1","val2","setDirtyFields","defaultValues","dirtyFields","parentName","shallowFieldsState","search","output","isString","startsWith","find","transformToNestObject","errors","error","validFields","fieldsWithValidation","previousError","RegExp","validationData","isRegex","message","getValidateError","isMessage","validateAllFieldCriteria","types","isRadio","isRadioOrCheckbox","isEmpty","appendErrorsCurry","appendErrors","bind","getMinMaxMessage","exceedMax","maxLengthMessage","minLengthMessage","maxType","minType","getValueAndMessage","exceedMin","maxOutput","minOutput","valueNumber","parseFloat","valueDate","maxLengthOutput","minLengthOutput","patternValue","getFieldsValue","validateRef","isFunction","validateError","validationResult","validateFunction","entries","validateResult","getPath","rootPath","paths","property","rootName","push","fieldValues","fieldName","watchFields","inputValue","isSingleField","add","isOnBlur","isOnChange","isOnTouch","isTouched","isReValidateOnBlur","isReValidateOnChange","isBlurEvent","isSubmitted","isOnAll","substring","indexOf","isMatchFieldArrayName","searchName","names","some","onDomRemove","removeFieldEventListenerAndRef","observer","MutationObserver","observe","window","document","childList","subtree","cloneObject","copy","isWeb","File","getTime","Set","Map","mode","isOnSubmit","isWindowUndefined","isProxyEnabled","Proxy","useForm","reValidateMode","resolver","context","shouldFocusError","criteriaMode","React.useRef","fieldArrayDefaultValuesRef","fieldArrayValuesRef","watchFieldsRef","useWatchFieldsRef","useWatchRenderFunctionsRef","fieldsWithValidationRef","validFieldsRef","defaultValuesRef","isUnMount","isWatchAllRef","handleChangeRef","resetFieldArrayFunctionRef","contextRef","resolverRef","fieldArrayNamesRef","modeRef","modeChecker","isValidateAllFieldCriteria","formState","setFormState","React.useState","isDirty","isValidating","submitCount","touched","isSubmitting","isSubmitSuccessful","readFormStateRef","formStateRef","observerRef","updateFormState","React.useCallback","state","updateIsValidating","shouldRenderBaseOnError","shouldRender","shouldReRender","isErrorStateChanged","setFieldValue","rawValue","radioRef","selectRef","includes","checkboxRef","isFormDirty","formValues","getValues","updateAndGetDirtyState","isFieldDirty","isDirtyFieldExist","previousIsDirty","isChanged","executeValidation","skipReRender","process","env","NODE_ENV","console","warn","validateField","executeSchemaOrResolverValidation","previousFormIsValid","isInputsValid","every","trigger","Promise","setInternalValues","shouldDirty","shouldValidate","setInternalValue","config","has","getNodeParentName","setFieldArrayDirtyFields","isFieldWatched","match","renderWatchedInputs","found","size","setValue","shouldSkipValidation","skipValidation","parentNodeName","currentError","setFieldArrayDefaultValues","payload","getFieldsValues","validateResolver","newDefaultValues","removeFieldEventListener","updateWatchedValue","watchField","clearErrors","inputName","setError","shouldFocus","watchInternal","fieldNames","watchId","assignWatchFields","combinedDefaultValues","watch","unregister","registerFieldRef","fieldRefAndValidationOptions","isRadioOrCheckboxFunction","isFieldArray","isNameInFieldArray","compareRef","currentRef","isEmptyDefaultValue","isEmptyUnmountFields","then","isSelectInput","register","refOrRegisterOptions","handleSubmit","onValid","onInvalid","e","preventDefault","persist","fieldError","focusOnErrorField","resetRefs","reset","omitResetState","inputRef","closest","resetFieldArray","React.useEffect","disconnect","commonProps","prop","control","React.useMemo","FormContext","React.createContext","displayName","useFormContext","React.useContext","FormProvider","_a","children","props","React.createElement","Provider","d","performance","now","c","r","Math","random","toString","removeAtIndexes","indexes","i","temp","splice","sort","from","to","indexA","indexB","prepend","insert","fill","mapIds","keyName","skipWarn","generateId","useFieldArray","methods","Error","focusIndexRef","getDefaultValues","fieldArrayParentName","getFieldArrayParentName","memoizedDefaultValues","setFields","omitKey","_b","omitted","rest","getFieldArrayValue","getCurrentFieldsValues","setFieldAndValidState","fieldsValues","resetFields","cleanup","updateDirtyFieldsWithDefaultValues","updatedFieldArrayValues","batchStateUpdate","method","args","updatedFieldValues","updatedFormValues","shouldSet","shouldUpdateValid","argA","argB","append","appendValue","updateFormValues","emptyArray","fillEmptyArray","prependAt","argC","fillBooleanArray","remove","removeArrayAt","insertAt","argD","swap","swapArrayAt","move","moveArrayAt","resetFunctions","fieldArrayNames","delete","event","useController","rules","onFocus","isNotFieldArray","getInitialValue","setInputStateValue","valueRef","onFocusRef","commonTask","getInputValue","registerField","shouldUpdateValue","defineProperties","meta","invalid","useWatch","updateValue","idRef","defaultValueRef","id","watchFieldsHookRender","watchFieldsHook","Controller","as","render","componentProps","React.cloneElement"],"sources":["/Users/balajibv/Documents/React/loan-application/node_modules/react-hook-form/src/utils/isHTMLElement.ts","/Users/balajibv/Documents/React/loan-application/node_modules/react-hook-form/src/constants.ts","/Users/balajibv/Documents/React/loan-application/node_modules/react-hook-form/src/logic/attachEventListeners.ts","/Users/balajibv/Documents/React/loan-application/node_modules/react-hook-form/src/utils/isNullOrUndefined.ts","/Users/balajibv/Documents/React/loan-application/node_modules/react-hook-form/src/utils/isObject.ts","/Users/balajibv/Documents/React/loan-application/node_modules/react-hook-form/src/utils/isKey.ts","/Users/balajibv/Documents/React/loan-application/node_modules/react-hook-form/src/utils/compact.ts","/Users/balajibv/Documents/React/loan-application/node_modules/react-hook-form/src/utils/stringToPath.ts","/Users/balajibv/Documents/React/loan-application/node_modules/react-hook-form/src/utils/set.ts","/Users/balajibv/Documents/React/loan-application/node_modules/react-hook-form/src/logic/transformToNestObject.ts","/Users/balajibv/Documents/React/loan-application/node_modules/react-hook-form/src/utils/isUndefined.ts","/Users/balajibv/Documents/React/loan-application/node_modules/react-hook-form/src/utils/get.ts","/Users/balajibv/Documents/React/loan-application/node_modules/react-hook-form/src/logic/focusOnErrorField.ts","/Users/balajibv/Documents/React/loan-application/node_modules/react-hook-form/src/logic/removeAllEventListeners.ts","/Users/balajibv/Documents/React/loan-application/node_modules/react-hook-form/src/logic/getRadioValue.ts","/Users/balajibv/Documents/React/loan-application/node_modules/react-hook-form/src/logic/getMultipleSelectValue.ts","/Users/balajibv/Documents/React/loan-application/node_modules/react-hook-form/src/utils/isRadioInput.ts","/Users/balajibv/Documents/React/loan-application/node_modules/react-hook-form/src/utils/isFileInput.ts","/Users/balajibv/Documents/React/loan-application/node_modules/react-hook-form/src/utils/isCheckBoxInput.ts","/Users/balajibv/Documents/React/loan-application/node_modules/react-hook-form/src/utils/isMultipleSelect.ts","/Users/balajibv/Documents/React/loan-application/node_modules/react-hook-form/src/logic/getCheckboxValue.ts","/Users/balajibv/Documents/React/loan-application/node_modules/react-hook-form/src/logic/getFieldValue.ts","/Users/balajibv/Documents/React/loan-application/node_modules/react-hook-form/src/utils/isDetached.ts","/Users/balajibv/Documents/React/loan-application/node_modules/react-hook-form/src/utils/isEmptyObject.ts","/Users/balajibv/Documents/React/loan-application/node_modules/react-hook-form/src/utils/isBoolean.ts","/Users/balajibv/Documents/React/loan-application/node_modules/react-hook-form/src/utils/unset.ts","/Users/balajibv/Documents/React/loan-application/node_modules/react-hook-form/src/logic/findRemovedFieldAndRemoveListener.ts","/Users/balajibv/Documents/React/loan-application/node_modules/react-hook-form/src/utils/isPrimitive.ts","/Users/balajibv/Documents/React/loan-application/node_modules/react-hook-form/src/utils/deepMerge.ts","/Users/balajibv/Documents/React/loan-application/node_modules/react-hook-form/src/utils/deepEqual.ts","/Users/balajibv/Documents/React/loan-application/node_modules/react-hook-form/src/logic/setFieldArrayDirtyFields.ts","/Users/balajibv/Documents/React/loan-application/node_modules/react-hook-form/src/utils/isString.ts","/Users/balajibv/Documents/React/loan-application/node_modules/react-hook-form/src/logic/getFieldsValues.ts","/Users/balajibv/Documents/React/loan-application/node_modules/react-hook-form/src/logic/isErrorStateChanged.ts","/Users/balajibv/Documents/React/loan-application/node_modules/react-hook-form/src/utils/isRegex.ts","/Users/balajibv/Documents/React/loan-application/node_modules/react-hook-form/src/logic/getValueAndMessage.ts","/Users/balajibv/Documents/React/loan-application/node_modules/react-hook-form/src/utils/isFunction.ts","/Users/balajibv/Documents/React/loan-application/node_modules/react-hook-form/src/utils/isMessage.ts","/Users/balajibv/Documents/React/loan-application/node_modules/react-hook-form/src/logic/getValidateError.ts","/Users/balajibv/Documents/React/loan-application/node_modules/react-hook-form/src/logic/appendErrors.ts","/Users/balajibv/Documents/React/loan-application/node_modules/react-hook-form/src/logic/validateField.ts","/Users/balajibv/Documents/React/loan-application/node_modules/react-hook-form/src/utils/getPath.ts","/Users/balajibv/Documents/React/loan-application/node_modules/react-hook-form/src/logic/assignWatchFields.ts","/Users/balajibv/Documents/React/loan-application/node_modules/react-hook-form/src/logic/skipValidation.ts","/Users/balajibv/Documents/React/loan-application/node_modules/react-hook-form/src/logic/getNodeParentName.ts","/Users/balajibv/Documents/React/loan-application/node_modules/react-hook-form/src/logic/isNameInFieldArray.ts","/Users/balajibv/Documents/React/loan-application/node_modules/react-hook-form/src/utils/isSelectInput.ts","/Users/balajibv/Documents/React/loan-application/node_modules/react-hook-form/src/utils/onDomRemove.ts","/Users/balajibv/Documents/React/loan-application/node_modules/react-hook-form/src/utils/isWeb.ts","/Users/balajibv/Documents/React/loan-application/node_modules/react-hook-form/src/utils/cloneObject.ts","/Users/balajibv/Documents/React/loan-application/node_modules/react-hook-form/src/utils/validationModeChecker.ts","/Users/balajibv/Documents/React/loan-application/node_modules/react-hook-form/src/utils/isRadioOrCheckbox.ts","/Users/balajibv/Documents/React/loan-application/node_modules/react-hook-form/src/useForm.ts","/Users/balajibv/Documents/React/loan-application/node_modules/react-hook-form/src/useFormContext.tsx","/Users/balajibv/Documents/React/loan-application/node_modules/react-hook-form/src/logic/generateId.ts","/Users/balajibv/Documents/React/loan-application/node_modules/react-hook-form/src/utils/remove.ts","/Users/balajibv/Documents/React/loan-application/node_modules/react-hook-form/src/utils/move.ts","/Users/balajibv/Documents/React/loan-application/node_modules/react-hook-form/src/utils/swap.ts","/Users/balajibv/Documents/React/loan-application/node_modules/react-hook-form/src/utils/prepend.ts","/Users/balajibv/Documents/React/loan-application/node_modules/react-hook-form/src/utils/insert.ts","/Users/balajibv/Documents/React/loan-application/node_modules/react-hook-form/src/utils/fillEmptyArray.ts","/Users/balajibv/Documents/React/loan-application/node_modules/react-hook-form/src/utils/fillBooleanArray.ts","/Users/balajibv/Documents/React/loan-application/node_modules/react-hook-form/src/useFieldArray.ts","/Users/balajibv/Documents/React/loan-application/node_modules/react-hook-form/src/logic/getInputValue.ts","/Users/balajibv/Documents/React/loan-application/node_modules/react-hook-form/src/useController.ts","/Users/balajibv/Documents/React/loan-application/node_modules/react-hook-form/src/useWatch.ts","/Users/balajibv/Documents/React/loan-application/node_modules/react-hook-form/src/controller.tsx"],"sourcesContent":["export default (value: any): value is HTMLElement =>\n  value instanceof HTMLElement;\n","import { ValidationMode } from './types';\n\nexport const EVENTS = {\n  BLUR: 'blur',\n  CHANGE: 'change',\n  INPUT: 'input',\n};\n\nexport const VALIDATION_MODE: ValidationMode = {\n  onBlur: 'onBlur',\n  onChange: 'onChange',\n  onSubmit: 'onSubmit',\n  onTouched: 'onTouched',\n  all: 'all',\n};\n\nexport const SELECT = 'select';\n\nexport const UNDEFINED = 'undefined';\n\nexport const INPUT_VALIDATION_RULES = {\n  max: 'max',\n  min: 'min',\n  maxLength: 'maxLength',\n  minLength: 'minLength',\n  pattern: 'pattern',\n  required: 'required',\n  validate: 'validate',\n};\n","import isHTMLElement from '../utils/isHTMLElement';\nimport { EVENTS } from '../constants';\nimport { Field } from '../types';\n\nexport default function attachEventListeners(\n  { ref }: Field,\n  shouldAttachChangeEvent?: boolean,\n  handleChange?: EventListenerOrEventListenerObject,\n): void {\n  if (isHTMLElement(ref) && handleChange) {\n    ref.addEventListener(\n      shouldAttachChangeEvent ? EVENTS.CHANGE : EVENTS.INPUT,\n      handleChange,\n    );\n    ref.addEventListener(EVENTS.BLUR, handleChange);\n  }\n}\n","export default (value: unknown): value is null | undefined => value == null;\n","import isNullOrUndefined from './isNullOrUndefined';\n\nexport const isObjectType = (value: unknown) => typeof value === 'object';\n\nexport default <T extends object>(value: unknown): value is T =>\n  !isNullOrUndefined(value) &&\n  !Array.isArray(value) &&\n  isObjectType(value) &&\n  !(value instanceof Date);\n","export default (value: string) => /^\\w*$/.test(value);\n","export default (value: any[]) => value.filter(Boolean);\n","import compact from './compact';\n\nexport default (input: string): string[] =>\n  compact(\n    input\n      .replace(/[\"|']/g, '')\n      .replace(/\\[/g, '.')\n      .replace(/\\]/g, '')\n      .split('.'),\n  );\n","import isObject from './isObject';\nimport isKey from './isKey';\nimport stringToPath from './stringToPath';\nimport { FieldValues } from '../types';\n\nexport default function set(\n  object: FieldValues,\n  path: string,\n  value?: unknown,\n) {\n  let index = -1;\n  const tempPath = isKey(path) ? [path] : stringToPath(path);\n  const length = tempPath.length;\n  const lastIndex = length - 1;\n\n  while (++index < length) {\n    const key = tempPath[index];\n    let newValue = value;\n\n    if (index !== lastIndex) {\n      const objValue = object[key];\n      newValue =\n        isObject(objValue) || Array.isArray(objValue)\n          ? objValue\n          : !isNaN(+tempPath[index + 1])\n          ? []\n          : {};\n    }\n    object[key] = newValue;\n    object = object[key];\n  }\n  return object;\n}\n","import set from '../utils/set';\nimport isKey from '../utils/isKey';\nimport { FieldValues } from '../types';\n\nexport default (data: FieldValues, value: Record<string, any> = {}): any => {\n  for (const key in data) {\n    !isKey(key) ? set(value, key, data[key]) : (value[key] = data[key]);\n  }\n  return value;\n};\n","export default (val: unknown): val is undefined => val === undefined;\n","import isUndefined from './isUndefined';\nimport isNullOrUndefined from './isNullOrUndefined';\nimport compact from './compact';\n\nexport default (obj: any = {}, path: string, defaultValue?: unknown) => {\n  const result = compact(path.split(/[,[\\].]+?/)).reduce(\n    (result, key) => (isNullOrUndefined(result) ? result : result[key]),\n    obj,\n  );\n\n  return isUndefined(result) || result === obj\n    ? isUndefined(obj[path])\n      ? defaultValue\n      : obj[path]\n    : result;\n};\n","import get from '../utils/get';\nimport isUndefined from '../utils/isUndefined';\nimport { FieldErrors, FieldRefs } from '../types';\n\nexport default <TFieldValues>(\n  fields: FieldRefs<TFieldValues>,\n  fieldErrors: FieldErrors<TFieldValues>,\n) => {\n  for (const key in fields) {\n    if (get(fieldErrors, key)) {\n      const field = fields[key];\n\n      if (field) {\n        if (field.ref.focus && isUndefined(field.ref.focus())) {\n          break;\n        } else if (field.options) {\n          field.options[0].ref.focus();\n\n          break;\n        }\n      }\n    }\n  }\n};\n","import isHTMLElement from '../utils/isHTMLElement';\nimport { EVENTS } from '../constants';\nimport { Ref } from '../types';\n\nexport default (\n  ref: Ref,\n  validateWithStateUpdate: EventListenerOrEventListenerObject,\n): void => {\n  if (isHTMLElement(ref) && ref.removeEventListener) {\n    ref.removeEventListener(EVENTS.INPUT, validateWithStateUpdate);\n    ref.removeEventListener(EVENTS.CHANGE, validateWithStateUpdate);\n    ref.removeEventListener(EVENTS.BLUR, validateWithStateUpdate);\n  }\n};\n","import { RadioOrCheckboxOption } from '../types';\n\ntype RadioFieldResult = {\n  isValid: boolean;\n  value: number | string | null;\n};\n\nconst defaultReturn: RadioFieldResult = {\n  isValid: false,\n  value: null,\n};\n\nexport default (options?: RadioOrCheckboxOption[]): RadioFieldResult =>\n  Array.isArray(options)\n    ? options.reduce(\n        (previous, option): RadioFieldResult =>\n          option && option.ref.checked\n            ? {\n                isValid: true,\n                value: option.ref.value,\n              }\n            : previous,\n        defaultReturn,\n      )\n    : defaultReturn;\n","export default (\n  options: HTMLOptionElement[] | HTMLOptionsCollection,\n): string[] =>\n  [...options]\n    .filter(({ selected }): boolean => selected)\n    .map(({ value }): string => value);\n","import { FieldElement } from '../types';\n\nexport default (element: FieldElement): element is HTMLInputElement =>\n  element.type === 'radio';\n","import { FieldElement } from '../types';\n\nexport default (element: FieldElement): element is HTMLInputElement =>\n  element.type === 'file';\n","import { FieldElement } from '../types';\n\nexport default (element: FieldElement): element is HTMLInputElement =>\n  element.type === 'checkbox';\n","import { FieldElement } from '../types';\nimport { SELECT } from '../constants';\n\nexport default (element: FieldElement): element is HTMLSelectElement =>\n  element.type === `${SELECT}-multiple`;\n","import isUndefined from '../utils/isUndefined';\nimport { RadioOrCheckboxOption } from '../types';\n\ntype CheckboxFieldResult = {\n  isValid: boolean;\n  value: string | string[] | boolean;\n};\n\nconst defaultResult: CheckboxFieldResult = {\n  value: false,\n  isValid: false,\n};\n\nconst validResult = { value: true, isValid: true };\n\nexport default (options?: RadioOrCheckboxOption[]): CheckboxFieldResult => {\n  if (Array.isArray(options)) {\n    if (options.length > 1) {\n      const values = options\n        .filter((option) => option && option.ref.checked)\n        .map(({ ref: { value } }) => value);\n      return { value: values, isValid: !!values.length };\n    }\n\n    const { checked, value, attributes } = options[0].ref;\n\n    return checked\n      ? attributes && !isUndefined((attributes as any).value)\n        ? isUndefined(value) || value === ''\n          ? validResult\n          : { value: value, isValid: true }\n        : validResult\n      : defaultResult;\n  }\n\n  return defaultResult;\n};\n","import * as React from 'react';\nimport getRadioValue from './getRadioValue';\nimport getMultipleSelectValue from './getMultipleSelectValue';\nimport isRadioInput from '../utils/isRadioInput';\nimport get from '../utils/get';\nimport isFileInput from '../utils/isFileInput';\nimport isCheckBox from '../utils/isCheckBoxInput';\nimport isMultipleSelect from '../utils/isMultipleSelect';\nimport getCheckboxValue from './getCheckboxValue';\nimport { FieldRefs, FieldValues, InternalFieldName } from '../types';\n\nexport default function getFieldValue<TFieldValues extends FieldValues>(\n  fieldsRef: React.MutableRefObject<FieldRefs<TFieldValues>>,\n  name: InternalFieldName<TFieldValues>,\n  shallowFieldsStateRef?: React.MutableRefObject<Partial<FieldValues>>,\n  excludeDisabled?: boolean,\n  shouldKeepRawValue?: boolean,\n) {\n  const field = fieldsRef.current[name]!;\n\n  if (field) {\n    const {\n      ref: { value, disabled },\n      ref,\n      valueAsNumber,\n      valueAsDate,\n      setValueAs,\n    } = field;\n\n    if (disabled && excludeDisabled) {\n      return;\n    }\n\n    if (isFileInput(ref)) {\n      return ref.files;\n    }\n\n    if (isRadioInput(ref)) {\n      return getRadioValue(field.options).value;\n    }\n\n    if (isMultipleSelect(ref)) {\n      return getMultipleSelectValue(ref.options);\n    }\n\n    if (isCheckBox(ref)) {\n      return getCheckboxValue(field.options).value;\n    }\n\n    return shouldKeepRawValue\n      ? value\n      : valueAsNumber\n      ? value === ''\n        ? NaN\n        : +value\n      : valueAsDate\n      ? (ref as HTMLInputElement).valueAsDate\n      : setValueAs\n      ? setValueAs(value)\n      : value;\n  }\n\n  if (shallowFieldsStateRef) {\n    return get(shallowFieldsStateRef.current, name);\n  }\n}\n","import { Ref } from '../types';\n\nexport default function isDetached(element: Ref): boolean {\n  if (!element) {\n    return true;\n  }\n\n  if (\n    !(element instanceof HTMLElement) ||\n    element.nodeType === Node.DOCUMENT_NODE\n  ) {\n    return false;\n  }\n\n  return isDetached(element.parentNode as Ref);\n}\n","import isObject from './isObject';\nimport { EmptyObject } from '../types';\n\nexport default (value: unknown): value is EmptyObject =>\n  isObject(value) && !Object.keys(value).length;\n","export default (value: unknown): value is boolean => typeof value === 'boolean';\n","import isKey from './isKey';\nimport stringToPath from './stringToPath';\nimport isEmptyObject from './isEmptyObject';\nimport isObject from './isObject';\nimport isUndefined from './isUndefined';\nimport isBoolean from './isBoolean';\n\nfunction baseGet(object: any, updatePath: (string | number)[]) {\n  const length = updatePath.slice(0, -1).length;\n  let index = 0;\n\n  while (index < length) {\n    object = isUndefined(object) ? index++ : object[updatePath[index++]];\n  }\n\n  return object;\n}\n\nexport default function unset(object: any, path: string) {\n  const updatePath = isKey(path) ? [path] : stringToPath(path);\n  const childObject =\n    updatePath.length == 1 ? object : baseGet(object, updatePath);\n  const key = updatePath[updatePath.length - 1];\n  let previousObjRef;\n\n  if (childObject) {\n    delete childObject[key];\n  }\n\n  for (let k = 0; k < updatePath.slice(0, -1).length; k++) {\n    let index = -1;\n    let objectRef;\n    const currentPaths = updatePath.slice(0, -(k + 1));\n    const currentPathsLength = currentPaths.length - 1;\n\n    if (k > 0) {\n      previousObjRef = object;\n    }\n\n    while (++index < currentPaths.length) {\n      const item = currentPaths[index];\n      objectRef = objectRef ? objectRef[item] : object[item];\n\n      if (\n        currentPathsLength === index &&\n        ((isObject(objectRef) && isEmptyObject(objectRef)) ||\n          (Array.isArray(objectRef) &&\n            !objectRef.filter(\n              (data) =>\n                (isObject(data) && !isEmptyObject(data)) || isBoolean(data),\n            ).length))\n      ) {\n        previousObjRef ? delete previousObjRef[item] : delete object[item];\n      }\n\n      previousObjRef = objectRef;\n    }\n  }\n\n  return object;\n}\n","import * as React from 'react';\nimport removeAllEventListeners from './removeAllEventListeners';\nimport getFieldValue from './getFieldValue';\nimport isRadioInput from '../utils/isRadioInput';\nimport set from '../utils/set';\nimport isCheckBoxInput from '../utils/isCheckBoxInput';\nimport isDetached from '../utils/isDetached';\nimport unset from '../utils/unset';\nimport compact from '../utils/compact';\nimport isUndefined from '../utils/isUndefined';\nimport { Field, FieldRefs, FieldValues, Ref } from '../types';\n\nconst isSameRef = (fieldValue: Field, ref: Ref) =>\n  fieldValue && fieldValue.ref === ref;\n\nexport default function findRemovedFieldAndRemoveListener<\n  TFieldValues extends FieldValues\n>(\n  fieldsRef: React.MutableRefObject<FieldRefs<TFieldValues>>,\n  handleChange: ({ type, target }: Event) => Promise<void | boolean>,\n  field: Field,\n  shallowFieldsStateRef: React.MutableRefObject<FieldValues>,\n  shouldUnregister?: boolean,\n  forceDelete?: boolean,\n): void {\n  const {\n    ref,\n    ref: { name },\n  } = field;\n  const fieldRef = fieldsRef.current[name] as Field;\n\n  if (!shouldUnregister) {\n    const value = getFieldValue(fieldsRef, name, shallowFieldsStateRef);\n\n    !isUndefined(value) && set(shallowFieldsStateRef.current, name, value);\n  }\n\n  if (!ref.type || !fieldRef) {\n    delete fieldsRef.current[name];\n    return;\n  }\n\n  if (isRadioInput(ref) || isCheckBoxInput(ref)) {\n    if (Array.isArray(fieldRef.options) && fieldRef.options.length) {\n      compact(fieldRef.options).forEach((option = {}, index): void => {\n        if (\n          (isDetached(option.ref) && isSameRef(option, option.ref)) ||\n          forceDelete\n        ) {\n          removeAllEventListeners(option.ref, handleChange);\n          unset(fieldRef.options, `[${index}]`);\n        }\n      });\n\n      if (fieldRef.options && !compact(fieldRef.options).length) {\n        delete fieldsRef.current[name];\n      }\n    } else {\n      delete fieldsRef.current[name];\n    }\n  } else if ((isDetached(ref) && isSameRef(fieldRef, ref)) || forceDelete) {\n    removeAllEventListeners(ref, handleChange);\n\n    delete fieldsRef.current[name];\n  }\n}\n","import isNullOrUndefined from './isNullOrUndefined';\nimport { isObjectType } from './isObject';\nimport { Primitive } from '../types';\n\nexport default (value: unknown): value is Primitive =>\n  isNullOrUndefined(value) || !isObjectType(value);\n","import isObject from './isObject';\nimport isPrimitive from './isPrimitive';\n\nexport function deepMerge<\n  T extends Record<keyof T, any>,\n  U extends Record<keyof U, any>\n>(target: T, source: U): T & U {\n  if (isPrimitive(target) || isPrimitive(source)) {\n    return source;\n  }\n\n  for (const key in source) {\n    const targetValue = target[key];\n    const sourceValue = source[key];\n\n    try {\n      target[key] =\n        (isObject(targetValue) && isObject(sourceValue)) ||\n        (Array.isArray(targetValue) && Array.isArray(sourceValue))\n          ? deepMerge(targetValue, sourceValue)\n          : sourceValue;\n    } catch {}\n  }\n\n  return target;\n}\n","import * as React from 'react';\nimport isObject from '../utils/isObject';\nimport isPrimitive from './isPrimitive';\n\nexport default function deepEqual(\n  object1: any,\n  object2: any,\n  isErrorObject?: boolean,\n) {\n  if (\n    isPrimitive(object1) ||\n    isPrimitive(object2) ||\n    object1 instanceof Date ||\n    object2 instanceof Date\n  ) {\n    return object1 === object2;\n  }\n\n  if (!React.isValidElement(object1)) {\n    const keys1 = Object.keys(object1);\n    const keys2 = Object.keys(object2);\n\n    if (keys1.length !== keys2.length) {\n      return false;\n    }\n\n    for (const key of keys1) {\n      const val1 = object1[key];\n\n      if (!(isErrorObject && key === 'ref')) {\n        const val2 = object2[key];\n\n        if (\n          (isObject(val1) || Array.isArray(val1)) &&\n          (isObject(val2) || Array.isArray(val2))\n            ? !deepEqual(val1, val2, isErrorObject)\n            : val1 !== val2\n        ) {\n          return false;\n        }\n      }\n    }\n  }\n\n  return true;\n}\n","import { get } from '../utils';\nimport set from '../utils/set';\nimport { deepMerge } from '../utils/deepMerge';\nimport deepEqual from '../utils/deepEqual';\n\nfunction setDirtyFields<\n  T extends Record<string, unknown>[],\n  U extends Record<string, unknown>[],\n  K extends Record<string, boolean | []>\n>(\n  values: T,\n  defaultValues: U,\n  dirtyFields: Record<string, boolean | []>[],\n  parentNode?: K,\n  parentName?: keyof K,\n) {\n  let index = -1;\n\n  while (++index < values.length) {\n    for (const key in values[index]) {\n      if (Array.isArray(values[index][key])) {\n        !dirtyFields[index] && (dirtyFields[index] = {});\n        dirtyFields[index][key] = [];\n        setDirtyFields(\n          values[index][key] as T,\n          get(defaultValues[index] || {}, key, []),\n          dirtyFields[index][key] as [],\n          dirtyFields[index],\n          key,\n        );\n      } else {\n        deepEqual(get(defaultValues[index] || {}, key), values[index][key])\n          ? set(dirtyFields[index] || {}, key)\n          : (dirtyFields[index] = {\n              ...dirtyFields[index],\n              [key]: true,\n            });\n      }\n    }\n\n    parentNode &&\n      !dirtyFields.length &&\n      delete parentNode[parentName as keyof K];\n  }\n\n  return dirtyFields;\n}\n\nexport default <T extends U, U extends Record<string, unknown>[]>(\n  values: T,\n  defaultValues: U,\n  dirtyFields: Record<string, boolean | []>[],\n) =>\n  deepMerge(\n    setDirtyFields(values, defaultValues, dirtyFields.slice(0, values.length)),\n    setDirtyFields(defaultValues, values, dirtyFields.slice(0, values.length)),\n  );\n","export default (value: unknown): value is string => typeof value === 'string';\n","import * as React from 'react';\nimport getFieldValue from './getFieldValue';\nimport isString from '../utils/isString';\nimport { deepMerge } from '../utils/deepMerge';\nimport isUndefined from '../utils/isUndefined';\nimport { InternalFieldName, FieldValues, FieldRefs } from '../types';\nimport transformToNestObject from './transformToNestObject';\n\nexport default <TFieldValues extends FieldValues>(\n  fieldsRef: React.MutableRefObject<FieldRefs<TFieldValues>>,\n  shallowFieldsState: Record<string, any>,\n  shouldUnregister: boolean,\n  excludeDisabled?: boolean,\n  search?:\n    | InternalFieldName<TFieldValues>\n    | InternalFieldName<TFieldValues>[]\n    | { nest: boolean },\n) => {\n  const output = {} as TFieldValues;\n\n  for (const name in fieldsRef.current) {\n    if (\n      isUndefined(search) ||\n      (isString(search)\n        ? name.startsWith(search)\n        : Array.isArray(search) && search.find((data) => name.startsWith(data)))\n    ) {\n      output[name as InternalFieldName<TFieldValues>] = getFieldValue(\n        fieldsRef,\n        name,\n        undefined,\n        excludeDisabled,\n      );\n    }\n  }\n\n  return shouldUnregister\n    ? transformToNestObject(output)\n    : deepMerge(shallowFieldsState, transformToNestObject(output));\n};\n","import get from '../utils/get';\nimport isUndefined from '../utils/isUndefined';\nimport deepEqual from '../utils/deepEqual';\nimport {\n  FieldValues,\n  InternalFieldName,\n  FieldErrors,\n  FieldNamesMarkedBoolean,\n  FieldError,\n} from '../types';\n\nexport default <TFieldValues extends FieldValues>({\n  errors,\n  name,\n  error,\n  validFields,\n  fieldsWithValidation,\n}: {\n  errors: FieldErrors<TFieldValues>;\n  error: FieldError | undefined;\n  name: InternalFieldName<TFieldValues>;\n  validFields: FieldNamesMarkedBoolean<TFieldValues>;\n  fieldsWithValidation: FieldNamesMarkedBoolean<TFieldValues>;\n}): boolean => {\n  const isValid = isUndefined(error);\n  const previousError = get(errors, name);\n\n  return (\n    (isValid && !!previousError) ||\n    (!isValid && !deepEqual(previousError, error, true)) ||\n    (isValid && get(fieldsWithValidation, name) && !get(validFields, name))\n  );\n};\n","export default (value: unknown): value is RegExp => value instanceof RegExp;\n","import isObject from '../utils/isObject';\nimport isRegex from '../utils/isRegex';\nimport { ValidationRule } from '../types';\n\nexport default (validationData?: ValidationRule) =>\n  isObject(validationData) && !isRegex(validationData)\n    ? validationData\n    : {\n        value: validationData,\n        message: '',\n      };\n","export default (value: unknown): value is Function =>\n  typeof value === 'function';\n","import * as React from 'react';\nimport isString from '../utils/isString';\nimport { Message } from '../types';\n\nexport default (value: unknown): value is Message =>\n  isString(value) || React.isValidElement(value as JSX.Element);\n","import isBoolean from '../utils/isBoolean';\nimport isMessage from '../utils/isMessage';\nimport { FieldError, ValidateResult, Ref } from '../types';\n\nexport default function getValidateError(\n  result: ValidateResult,\n  ref: Ref,\n  type = 'validate',\n): FieldError | void {\n  if (isMessage(result) || (isBoolean(result) && !result)) {\n    return {\n      type,\n      message: isMessage(result) ? result : '',\n      ref,\n    };\n  }\n}\n","import {\n  InternalFieldName,\n  ValidateResult,\n  InternalFieldErrors,\n} from '../types';\n\nexport default <TFieldValues>(\n  name: InternalFieldName<TFieldValues>,\n  validateAllFieldCriteria: boolean,\n  errors: InternalFieldErrors<TFieldValues>,\n  type: string,\n  message: ValidateResult,\n) =>\n  validateAllFieldCriteria\n    ? {\n        ...errors[name],\n        types: {\n          ...(errors[name] && errors[name]!.types ? errors[name]!.types : {}),\n          [type]: message || true,\n        },\n      }\n    : {};\n","import * as React from 'react';\nimport getRadioValue from './getRadioValue';\nimport getCheckboxValue from './getCheckboxValue';\nimport isNullOrUndefined from '../utils/isNullOrUndefined';\nimport isRadioInput from '../utils/isRadioInput';\nimport getValueAndMessage from './getValueAndMessage';\nimport isCheckBoxInput from '../utils/isCheckBoxInput';\nimport isString from '../utils/isString';\nimport isEmptyObject from '../utils/isEmptyObject';\nimport isObject from '../utils/isObject';\nimport isFunction from '../utils/isFunction';\nimport getFieldsValue from './getFieldValue';\nimport isRegex from '../utils/isRegex';\nimport isBoolean from '../utils/isBoolean';\nimport isMessage from '../utils/isMessage';\nimport getValidateError from './getValidateError';\nimport appendErrors from './appendErrors';\nimport { INPUT_VALIDATION_RULES } from '../constants';\nimport {\n  Field,\n  FieldValues,\n  FieldRefs,\n  Message,\n  FieldError,\n  InternalFieldName,\n  InternalFieldErrors,\n} from '../types';\n\nexport default async <TFieldValues extends FieldValues>(\n  fieldsRef: React.MutableRefObject<FieldRefs<TFieldValues>>,\n  validateAllFieldCriteria: boolean,\n  {\n    ref,\n    ref: { value },\n    options,\n    required,\n    maxLength,\n    minLength,\n    min,\n    max,\n    pattern,\n    validate,\n  }: Field,\n  shallowFieldsStateRef: React.MutableRefObject<Record<string, any>>,\n): Promise<InternalFieldErrors<TFieldValues>> => {\n  const name: InternalFieldName<TFieldValues> = ref.name;\n  const error: InternalFieldErrors<TFieldValues> = {};\n  const isRadio = isRadioInput(ref);\n  const isCheckBox = isCheckBoxInput(ref);\n  const isRadioOrCheckbox = isRadio || isCheckBox;\n  const isEmpty = value === '';\n  const appendErrorsCurry = appendErrors.bind(\n    null,\n    name,\n    validateAllFieldCriteria,\n    error,\n  );\n  const getMinMaxMessage = (\n    exceedMax: boolean,\n    maxLengthMessage: Message,\n    minLengthMessage: Message,\n    maxType = INPUT_VALIDATION_RULES.maxLength,\n    minType = INPUT_VALIDATION_RULES.minLength,\n  ) => {\n    const message = exceedMax ? maxLengthMessage : minLengthMessage;\n    error[name] = {\n      type: exceedMax ? maxType : minType,\n      message,\n      ref,\n      ...(exceedMax\n        ? appendErrorsCurry(maxType, message)\n        : appendErrorsCurry(minType, message)),\n    };\n  };\n\n  if (\n    required &&\n    ((!isRadio && !isCheckBox && (isEmpty || isNullOrUndefined(value))) ||\n      (isBoolean(value) && !value) ||\n      (isCheckBox && !getCheckboxValue(options).isValid) ||\n      (isRadio && !getRadioValue(options).isValid))\n  ) {\n    const { value, message } = isMessage(required)\n      ? { value: !!required, message: required }\n      : getValueAndMessage(required);\n\n    if (value) {\n      error[name] = {\n        type: INPUT_VALIDATION_RULES.required,\n        message,\n        ref: isRadioOrCheckbox\n          ? (((fieldsRef.current[name] as Field).options || [])[0] || {}).ref\n          : ref,\n        ...appendErrorsCurry(INPUT_VALIDATION_RULES.required, message),\n      };\n      if (!validateAllFieldCriteria) {\n        return error;\n      }\n    }\n  }\n\n  if ((!isNullOrUndefined(min) || !isNullOrUndefined(max)) && value !== '') {\n    let exceedMax;\n    let exceedMin;\n    const maxOutput = getValueAndMessage(max);\n    const minOutput = getValueAndMessage(min);\n\n    if (!isNaN(value)) {\n      const valueNumber =\n        (ref as HTMLInputElement).valueAsNumber || parseFloat(value);\n      if (!isNullOrUndefined(maxOutput.value)) {\n        exceedMax = valueNumber > maxOutput.value;\n      }\n      if (!isNullOrUndefined(minOutput.value)) {\n        exceedMin = valueNumber < minOutput.value;\n      }\n    } else {\n      const valueDate =\n        (ref as HTMLInputElement).valueAsDate || new Date(value);\n      if (isString(maxOutput.value)) {\n        exceedMax = valueDate > new Date(maxOutput.value);\n      }\n      if (isString(minOutput.value)) {\n        exceedMin = valueDate < new Date(minOutput.value);\n      }\n    }\n\n    if (exceedMax || exceedMin) {\n      getMinMaxMessage(\n        !!exceedMax,\n        maxOutput.message,\n        minOutput.message,\n        INPUT_VALIDATION_RULES.max,\n        INPUT_VALIDATION_RULES.min,\n      );\n      if (!validateAllFieldCriteria) {\n        return error;\n      }\n    }\n  }\n\n  if (isString(value) && !isEmpty && (maxLength || minLength)) {\n    const maxLengthOutput = getValueAndMessage(maxLength);\n    const minLengthOutput = getValueAndMessage(minLength);\n    const exceedMax =\n      !isNullOrUndefined(maxLengthOutput.value) &&\n      value.length > maxLengthOutput.value;\n    const exceedMin =\n      !isNullOrUndefined(minLengthOutput.value) &&\n      value.length < minLengthOutput.value;\n\n    if (exceedMax || exceedMin) {\n      getMinMaxMessage(\n        exceedMax,\n        maxLengthOutput.message,\n        minLengthOutput.message,\n      );\n      if (!validateAllFieldCriteria) {\n        return error;\n      }\n    }\n  }\n\n  if (isString(value) && pattern && !isEmpty) {\n    const { value: patternValue, message } = getValueAndMessage(pattern);\n\n    if (isRegex(patternValue) && !patternValue.test(value)) {\n      error[name] = {\n        type: INPUT_VALIDATION_RULES.pattern,\n        message,\n        ref,\n        ...appendErrorsCurry(INPUT_VALIDATION_RULES.pattern, message),\n      };\n      if (!validateAllFieldCriteria) {\n        return error;\n      }\n    }\n  }\n\n  if (validate) {\n    const fieldValue = getFieldsValue(\n      fieldsRef,\n      name,\n      shallowFieldsStateRef,\n      false,\n      true,\n    );\n    const validateRef = isRadioOrCheckbox && options ? options[0].ref : ref;\n\n    if (isFunction(validate)) {\n      const result = await validate(fieldValue);\n      const validateError = getValidateError(result, validateRef);\n\n      if (validateError) {\n        error[name] = {\n          ...validateError,\n          ...appendErrorsCurry(\n            INPUT_VALIDATION_RULES.validate,\n            validateError.message,\n          ),\n        };\n        if (!validateAllFieldCriteria) {\n          return error;\n        }\n      }\n    } else if (isObject(validate)) {\n      let validationResult = {} as FieldError;\n      for (const [key, validateFunction] of Object.entries(validate)) {\n        if (!isEmptyObject(validationResult) && !validateAllFieldCriteria) {\n          break;\n        }\n\n        const validateResult = await validateFunction(fieldValue);\n        const validateError = getValidateError(\n          validateResult,\n          validateRef,\n          key,\n        );\n\n        if (validateError) {\n          validationResult = {\n            ...validateError,\n            ...appendErrorsCurry(key, validateError.message),\n          };\n\n          if (validateAllFieldCriteria) {\n            error[name] = validationResult;\n          }\n        }\n      }\n\n      if (!isEmptyObject(validationResult)) {\n        error[name] = {\n          ref: validateRef,\n          ...validationResult,\n        };\n        if (!validateAllFieldCriteria) {\n          return error;\n        }\n      }\n    }\n  }\n\n  return error;\n};\n","import isPrimitive from './isPrimitive';\nimport isObject from './isObject';\nimport { FieldName } from '../types';\n\nexport const getPath = <TFieldValues>(\n  rootPath: FieldName<TFieldValues>,\n  values: any,\n  paths: FieldName<TFieldValues>[] = [],\n): FieldName<TFieldValues>[] => {\n  for (const property in values) {\n    const rootName = (rootPath +\n      (isObject(values)\n        ? `.${property}`\n        : `[${property}]`)) as FieldName<TFieldValues>;\n\n    isPrimitive(values[property])\n      ? paths.push(rootName)\n      : getPath(rootName, values[property], paths);\n  }\n\n  return paths;\n};\n","import get from '../utils/get';\nimport { getPath } from '../utils/getPath';\nimport isEmptyObject from '../utils/isEmptyObject';\nimport isUndefined from '../utils/isUndefined';\nimport isObject from '../utils/isObject';\nimport {\n  DeepPartial,\n  FieldValue,\n  FieldValues,\n  InternalFieldName,\n  UnpackNestedValue,\n} from '../types';\n\nexport default <TFieldValues extends FieldValues>(\n  fieldValues: TFieldValues,\n  fieldName: InternalFieldName<TFieldValues>,\n  watchFields: Set<InternalFieldName<TFieldValues>>,\n  inputValue: UnpackNestedValue<DeepPartial<TFieldValues>>,\n  isSingleField?: boolean,\n):\n  | FieldValue<TFieldValues>\n  | UnpackNestedValue<DeepPartial<TFieldValues>>\n  | undefined => {\n  let value = undefined;\n\n  watchFields.add(fieldName);\n\n  if (!isEmptyObject(fieldValues)) {\n    value = get(fieldValues, fieldName);\n\n    if (isObject(value) || Array.isArray(value)) {\n      getPath(fieldName, value).forEach((name) => watchFields.add(name));\n    }\n  }\n\n  return isUndefined(value)\n    ? isSingleField\n      ? inputValue\n      : get(inputValue, fieldName)\n    : value;\n};\n","export default ({\n  isOnBlur,\n  isOnChange,\n  isOnTouch,\n  isTouched,\n  isReValidateOnBlur,\n  isReValidateOnChange,\n  isBlurEvent,\n  isSubmitted,\n  isOnAll,\n}: {\n  isOnAll?: boolean;\n  isOnBlur?: boolean;\n  isOnChange?: boolean;\n  isReValidateOnBlur?: boolean;\n  isReValidateOnChange?: boolean;\n  isBlurEvent?: boolean;\n  isSubmitted?: boolean;\n  isOnTouch?: boolean;\n  isTouched?: boolean;\n}) => {\n  if (isOnAll) {\n    return false;\n  } else if (!isSubmitted && isOnTouch) {\n    return !(isTouched || isBlurEvent);\n  } else if (isSubmitted ? isReValidateOnBlur : isOnBlur) {\n    return !isBlurEvent;\n  } else if (isSubmitted ? isReValidateOnChange : isOnChange) {\n    return isBlurEvent;\n  }\n  return true;\n};\n","export default (name: string) => name.substring(0, name.indexOf('['));\n","import { FieldValues, InternalFieldName } from '../types';\n\nexport const isMatchFieldArrayName = (name: string, searchName: string) =>\n  RegExp(\n    `^${searchName}([|.)\\\\d+`.replace(/\\[/g, '\\\\[').replace(/\\]/g, '\\\\]'),\n  ).test(name);\n\nexport default (\n  names: Set<InternalFieldName<FieldValues>>,\n  name: InternalFieldName<FieldValues>,\n) => [...names].some((current) => isMatchFieldArrayName(name, current));\n","import { FieldElement } from '../types';\nimport { SELECT } from '../constants';\n\nexport default (element: FieldElement): element is HTMLSelectElement =>\n  element.type === `${SELECT}-one`;\n","import * as React from 'react';\nimport { Field, FieldRefs } from '../types';\nimport isDetached from './isDetached';\n\nexport default function onDomRemove<TFieldValues>(\n  fieldsRef: React.MutableRefObject<FieldRefs<TFieldValues>>,\n  removeFieldEventListenerAndRef: (\n    field: Field | undefined,\n    forceDelete?: boolean,\n  ) => void,\n): MutationObserver {\n  const observer = new MutationObserver((): void => {\n    for (const field of Object.values(fieldsRef.current)) {\n      if (field && field.options) {\n        for (const option of field.options) {\n          if (option && option.ref && isDetached(option.ref)) {\n            removeFieldEventListenerAndRef(field);\n          }\n        }\n      } else if (field && isDetached(field.ref)) {\n        removeFieldEventListenerAndRef(field);\n      }\n    }\n  });\n\n  observer.observe(window.document, {\n    childList: true,\n    subtree: true,\n  });\n\n  return observer;\n}\n","import { UNDEFINED } from '../constants';\n\nexport default typeof window !== UNDEFINED && typeof document !== UNDEFINED;\n","import isPrimitive from './isPrimitive';\nimport isHTMLElement from './isHTMLElement';\nimport isWeb from './isWeb';\n\nexport default function cloneObject<T extends unknown>(data: T): T {\n  let copy: any;\n\n  if (\n    isPrimitive(data) ||\n    (isWeb && (data instanceof File || isHTMLElement(data)))\n  ) {\n    return data;\n  }\n\n  if (data instanceof Date) {\n    copy = new Date(data.getTime());\n    return copy;\n  }\n\n  if (data instanceof Set) {\n    copy = new Set();\n    for (const item of data) {\n      copy.add(item);\n    }\n    return copy;\n  }\n\n  if (data instanceof Map) {\n    copy = new Map();\n    for (const key of data.keys()) {\n      copy.set(key, cloneObject(data.get(key)));\n    }\n    return copy;\n  }\n\n  copy = Array.isArray(data) ? [] : {};\n\n  for (const key in data) {\n    copy[key] = cloneObject(data[key]);\n  }\n\n  return copy;\n}\n","import { VALIDATION_MODE } from '../constants';\nimport { Mode } from '../types';\n\nexport default (\n  mode?: Mode,\n): {\n  isOnSubmit: boolean;\n  isOnBlur: boolean;\n  isOnChange: boolean;\n  isOnAll: boolean;\n  isOnTouch: boolean;\n} => ({\n  isOnSubmit: !mode || mode === VALIDATION_MODE.onSubmit,\n  isOnBlur: mode === VALIDATION_MODE.onBlur,\n  isOnChange: mode === VALIDATION_MODE.onChange,\n  isOnAll: mode === VALIDATION_MODE.all,\n  isOnTouch: mode === VALIDATION_MODE.onTouched,\n});\n","import isRadioInput from './isRadioInput';\nimport isCheckBoxInput from './isCheckBoxInput';\nimport { FieldElement } from '../types';\n\nexport default (ref: FieldElement): ref is HTMLInputElement =>\n  isRadioInput(ref) || isCheckBoxInput(ref);\n","import * as React from 'react';\nimport attachEventListeners from './logic/attachEventListeners';\nimport transformToNestObject from './logic/transformToNestObject';\nimport focusOnErrorField from './logic/focusOnErrorField';\nimport findRemovedFieldAndRemoveListener from './logic/findRemovedFieldAndRemoveListener';\nimport setFieldArrayDirtyFields from './logic/setFieldArrayDirtyFields';\nimport getFieldsValues from './logic/getFieldsValues';\nimport getFieldValue from './logic/getFieldValue';\nimport isErrorStateChanged from './logic/isErrorStateChanged';\nimport validateField from './logic/validateField';\nimport assignWatchFields from './logic/assignWatchFields';\nimport skipValidation from './logic/skipValidation';\nimport getNodeParentName from './logic/getNodeParentName';\nimport deepEqual from './utils/deepEqual';\nimport isNameInFieldArray from './logic/isNameInFieldArray';\nimport isCheckBoxInput from './utils/isCheckBoxInput';\nimport isEmptyObject from './utils/isEmptyObject';\nimport isRadioInput from './utils/isRadioInput';\nimport isSelectInput from './utils/isSelectInput';\nimport isFileInput from './utils/isFileInput';\nimport onDomRemove from './utils/onDomRemove';\nimport isObject from './utils/isObject';\nimport { getPath } from './utils/getPath';\nimport isPrimitive from './utils/isPrimitive';\nimport isFunction from './utils/isFunction';\nimport isString from './utils/isString';\nimport isUndefined from './utils/isUndefined';\nimport get from './utils/get';\nimport set from './utils/set';\nimport unset from './utils/unset';\nimport isKey from './utils/isKey';\nimport cloneObject from './utils/cloneObject';\nimport modeChecker from './utils/validationModeChecker';\nimport isMultipleSelect from './utils/isMultipleSelect';\nimport compact from './utils/compact';\nimport isNullOrUndefined from './utils/isNullOrUndefined';\nimport isRadioOrCheckboxFunction from './utils/isRadioOrCheckbox';\nimport isWeb from './utils/isWeb';\nimport isHTMLElement from './utils/isHTMLElement';\nimport { EVENTS, UNDEFINED, VALIDATION_MODE } from './constants';\nimport {\n  UseFormMethods,\n  FieldValues,\n  UnpackNestedValue,\n  FieldName,\n  InternalFieldName,\n  FieldErrors,\n  Field,\n  FieldRefs,\n  UseFormOptions,\n  RegisterOptions,\n  SubmitHandler,\n  FieldElement,\n  FormStateProxy,\n  ReadFormState,\n  Ref,\n  HandleChange,\n  RadioOrCheckboxOption,\n  OmitResetState,\n  SetValueConfig,\n  ErrorOption,\n  FormState,\n  SubmitErrorHandler,\n  FieldNamesMarkedBoolean,\n  LiteralToPrimitive,\n  DeepPartial,\n  InternalNameSet,\n  DefaultValues,\n  FieldError,\n  SetFieldValue,\n  FieldArrayDefaultValues,\n  ResetFieldArrayFunctionRef,\n  UseWatchRenderFunctions,\n  RecordInternalNameSet,\n} from './types';\n\nconst isWindowUndefined = typeof window === UNDEFINED;\nconst isProxyEnabled = isWeb ? 'Proxy' in window : typeof Proxy !== UNDEFINED;\n\nexport function useForm<\n  TFieldValues extends FieldValues = FieldValues,\n  TContext extends object = object\n>({\n  mode = VALIDATION_MODE.onSubmit,\n  reValidateMode = VALIDATION_MODE.onChange,\n  resolver,\n  context,\n  defaultValues = {} as DefaultValues<TFieldValues>,\n  shouldFocusError = true,\n  shouldUnregister = true,\n  criteriaMode,\n}: UseFormOptions<TFieldValues, TContext> = {}): UseFormMethods<TFieldValues> {\n  const fieldsRef = React.useRef<FieldRefs<TFieldValues>>({});\n  const fieldArrayDefaultValuesRef = React.useRef<FieldArrayDefaultValues>({});\n  const fieldArrayValuesRef = React.useRef<FieldArrayDefaultValues>({});\n  const watchFieldsRef = React.useRef<InternalNameSet<TFieldValues>>(new Set());\n  const useWatchFieldsRef = React.useRef<RecordInternalNameSet<TFieldValues>>(\n    {},\n  );\n  const useWatchRenderFunctionsRef = React.useRef<UseWatchRenderFunctions>({});\n  const fieldsWithValidationRef = React.useRef<\n    FieldNamesMarkedBoolean<TFieldValues>\n  >({});\n  const validFieldsRef = React.useRef<FieldNamesMarkedBoolean<TFieldValues>>(\n    {},\n  );\n  const defaultValuesRef = React.useRef<DefaultValues<TFieldValues>>(\n    defaultValues,\n  );\n  const isUnMount = React.useRef(false);\n  const isWatchAllRef = React.useRef(false);\n  const handleChangeRef = React.useRef<HandleChange>();\n  const shallowFieldsStateRef = React.useRef({});\n  const resetFieldArrayFunctionRef = React.useRef<\n    ResetFieldArrayFunctionRef<TFieldValues>\n  >({});\n  const contextRef = React.useRef(context);\n  const resolverRef = React.useRef(resolver);\n  const fieldArrayNamesRef = React.useRef<InternalNameSet<TFieldValues>>(\n    new Set(),\n  );\n  const modeRef = React.useRef(modeChecker(mode));\n  const { isOnSubmit, isOnTouch } = modeRef.current;\n  const isValidateAllFieldCriteria = criteriaMode === VALIDATION_MODE.all;\n  const [formState, setFormState] = React.useState<FormState<TFieldValues>>({\n    isDirty: false,\n    isValidating: false,\n    dirtyFields: {},\n    isSubmitted: false,\n    submitCount: 0,\n    touched: {},\n    isSubmitting: false,\n    isSubmitSuccessful: false,\n    isValid: !isOnSubmit,\n    errors: {},\n  });\n  const readFormStateRef = React.useRef<ReadFormState>({\n    isDirty: !isProxyEnabled,\n    dirtyFields: !isProxyEnabled,\n    touched: !isProxyEnabled || isOnTouch,\n    isValidating: !isProxyEnabled,\n    isSubmitting: !isProxyEnabled,\n    isValid: !isProxyEnabled,\n  });\n  const formStateRef = React.useRef(formState);\n  const observerRef = React.useRef<MutationObserver | undefined>();\n  const {\n    isOnBlur: isReValidateOnBlur,\n    isOnChange: isReValidateOnChange,\n  } = React.useRef(modeChecker(reValidateMode)).current;\n\n  contextRef.current = context;\n  resolverRef.current = resolver;\n  formStateRef.current = formState;\n  shallowFieldsStateRef.current = shouldUnregister\n    ? {}\n    : isEmptyObject(shallowFieldsStateRef.current)\n    ? cloneObject(defaultValues)\n    : shallowFieldsStateRef.current;\n\n  const updateFormState = React.useCallback(\n    (state: Partial<FormState<TFieldValues>> = {}) => {\n      if (!isUnMount.current) {\n        formStateRef.current = {\n          ...formStateRef.current,\n          ...state,\n        };\n        setFormState(formStateRef.current);\n      }\n    },\n    [],\n  );\n\n  const updateIsValidating = () =>\n    readFormStateRef.current.isValidating &&\n    updateFormState({\n      isValidating: true,\n    });\n\n  const shouldRenderBaseOnError = React.useCallback(\n    (\n      name: InternalFieldName<TFieldValues>,\n      error: FieldError | undefined,\n      shouldRender: boolean | null = false,\n      state: {\n        dirtyFields?: FieldNamesMarkedBoolean<TFieldValues>;\n        isDirty?: boolean;\n        touched?: FieldNamesMarkedBoolean<TFieldValues>;\n      } = {},\n      isValid?: boolean,\n    ): boolean | void => {\n      let shouldReRender =\n        shouldRender ||\n        isErrorStateChanged<TFieldValues>({\n          errors: formStateRef.current.errors,\n          error,\n          name,\n          validFields: validFieldsRef.current,\n          fieldsWithValidation: fieldsWithValidationRef.current,\n        });\n      const previousError = get(formStateRef.current.errors, name);\n\n      if (error) {\n        unset(validFieldsRef.current, name);\n        shouldReRender =\n          shouldReRender ||\n          !previousError ||\n          !deepEqual(previousError, error, true);\n        set(formStateRef.current.errors, name, error);\n      } else {\n        if (get(fieldsWithValidationRef.current, name) || resolverRef.current) {\n          set(validFieldsRef.current, name, true);\n          shouldReRender = shouldReRender || previousError;\n        }\n\n        unset(formStateRef.current.errors, name);\n      }\n\n      if (\n        (shouldReRender && !isNullOrUndefined(shouldRender)) ||\n        !isEmptyObject(state) ||\n        readFormStateRef.current.isValidating\n      ) {\n        updateFormState({\n          ...state,\n          ...(resolverRef.current ? { isValid: !!isValid } : {}),\n          isValidating: false,\n        });\n      }\n    },\n    [],\n  );\n\n  const setFieldValue = React.useCallback(\n    (name: FieldName<TFieldValues>, rawValue: SetFieldValue<TFieldValues>) => {\n      const { ref, options } = fieldsRef.current[name] as Field;\n      const value =\n        isWeb && isHTMLElement(ref) && isNullOrUndefined(rawValue)\n          ? ''\n          : rawValue;\n\n      if (isRadioInput(ref)) {\n        (options || []).forEach(\n          ({ ref: radioRef }: { ref: HTMLInputElement }) =>\n            (radioRef.checked = radioRef.value === value),\n        );\n      } else if (isFileInput(ref) && !isString(value)) {\n        ref.files = value as FileList;\n      } else if (isMultipleSelect(ref)) {\n        [...ref.options].forEach(\n          (selectRef) =>\n            (selectRef.selected = (value as string[]).includes(\n              selectRef.value,\n            )),\n        );\n      } else if (isCheckBoxInput(ref) && options) {\n        options.length > 1\n          ? options.forEach(\n              ({ ref: checkboxRef }) =>\n                (checkboxRef.checked = Array.isArray(value)\n                  ? !!(value as []).find(\n                      (data: string) => data === checkboxRef.value,\n                    )\n                  : value === checkboxRef.value),\n            )\n          : (options[0].ref.checked = !!value);\n      } else {\n        ref.value = value;\n      }\n    },\n    [],\n  );\n\n  const isFormDirty = React.useCallback(\n    (name?: string, data?: unknown[]): boolean => {\n      if (readFormStateRef.current.isDirty) {\n        const formValues = getValues();\n\n        name && data && set(formValues, name, data);\n\n        return !deepEqual(formValues, defaultValuesRef.current);\n      }\n\n      return false;\n    },\n    [],\n  );\n\n  const updateAndGetDirtyState = React.useCallback(\n    (\n      name: InternalFieldName<TFieldValues>,\n      shouldRender = true,\n    ): Partial<\n      Pick<FormState<TFieldValues>, 'dirtyFields' | 'isDirty' | 'touched'>\n    > => {\n      if (\n        readFormStateRef.current.isDirty ||\n        readFormStateRef.current.dirtyFields\n      ) {\n        const isFieldDirty = !deepEqual(\n          get(defaultValuesRef.current, name),\n          getFieldValue(fieldsRef, name, shallowFieldsStateRef),\n        );\n        const isDirtyFieldExist = get(formStateRef.current.dirtyFields, name);\n        const previousIsDirty = formStateRef.current.isDirty;\n\n        isFieldDirty\n          ? set(formStateRef.current.dirtyFields, name, true)\n          : unset(formStateRef.current.dirtyFields, name);\n\n        const state = {\n          isDirty: isFormDirty(),\n          dirtyFields: formStateRef.current.dirtyFields,\n        };\n\n        const isChanged =\n          (readFormStateRef.current.isDirty &&\n            previousIsDirty !== state.isDirty) ||\n          (readFormStateRef.current.dirtyFields &&\n            isDirtyFieldExist !== get(formStateRef.current.dirtyFields, name));\n\n        isChanged && shouldRender && updateFormState(state);\n\n        return isChanged ? state : {};\n      }\n\n      return {};\n    },\n    [],\n  );\n\n  const executeValidation = React.useCallback(\n    async (\n      name: InternalFieldName<TFieldValues>,\n      skipReRender?: boolean | null,\n    ): Promise<boolean> => {\n      if (process.env.NODE_ENV !== 'production') {\n        if (!fieldsRef.current[name]) {\n          console.warn('📋 Field is missing with `name` attribute: ', name);\n          return false;\n        }\n      }\n\n      const error = (\n        await validateField<TFieldValues>(\n          fieldsRef,\n          isValidateAllFieldCriteria,\n          fieldsRef.current[name] as Field,\n          shallowFieldsStateRef,\n        )\n      )[name];\n\n      shouldRenderBaseOnError(name, error, skipReRender);\n\n      return isUndefined(error);\n    },\n    [shouldRenderBaseOnError, isValidateAllFieldCriteria],\n  );\n\n  const executeSchemaOrResolverValidation = React.useCallback(\n    async (\n      names:\n        | InternalFieldName<TFieldValues>\n        | InternalFieldName<TFieldValues>[],\n    ) => {\n      const { errors } = await resolverRef.current!(\n        getValues(),\n        contextRef.current,\n        isValidateAllFieldCriteria,\n      );\n      const previousFormIsValid = formStateRef.current.isValid;\n\n      if (Array.isArray(names)) {\n        const isInputsValid = names\n          .map((name) => {\n            const error = get(errors, name);\n\n            error\n              ? set(formStateRef.current.errors, name, error)\n              : unset(formStateRef.current.errors, name);\n\n            return !error;\n          })\n          .every(Boolean);\n\n        updateFormState({\n          isValid: isEmptyObject(errors),\n          isValidating: false,\n        });\n\n        return isInputsValid;\n      } else {\n        const error = get(errors, names);\n\n        shouldRenderBaseOnError(\n          names,\n          error,\n          previousFormIsValid !== isEmptyObject(errors),\n          {},\n          isEmptyObject(errors),\n        );\n\n        return !error;\n      }\n    },\n    [shouldRenderBaseOnError, isValidateAllFieldCriteria],\n  );\n\n  const trigger = React.useCallback(\n    async (\n      name?: FieldName<TFieldValues> | FieldName<TFieldValues>[],\n    ): Promise<boolean> => {\n      const fields = name || Object.keys(fieldsRef.current);\n\n      updateIsValidating();\n\n      if (resolverRef.current) {\n        return executeSchemaOrResolverValidation(fields);\n      }\n\n      if (Array.isArray(fields)) {\n        !name && (formStateRef.current.errors = {});\n        const result = await Promise.all(\n          fields.map(async (data) => await executeValidation(data, null)),\n        );\n        updateFormState({\n          isValidating: false,\n        });\n        return result.every(Boolean);\n      }\n\n      return await executeValidation(fields);\n    },\n    [executeSchemaOrResolverValidation, executeValidation],\n  );\n\n  const setInternalValues = React.useCallback(\n    (\n      name: FieldName<TFieldValues>,\n      value: SetFieldValue<TFieldValues>,\n      { shouldDirty, shouldValidate }: SetValueConfig,\n    ) => {\n      const data = {};\n      set(data, name, value);\n\n      for (const fieldName of getPath(name, value)) {\n        if (fieldsRef.current[fieldName]) {\n          setFieldValue(fieldName, get(data, fieldName));\n          shouldDirty && updateAndGetDirtyState(fieldName);\n          shouldValidate && trigger(fieldName as FieldName<TFieldValues>);\n        }\n      }\n    },\n    [trigger, setFieldValue, updateAndGetDirtyState],\n  );\n\n  const setInternalValue = React.useCallback(\n    (\n      name: FieldName<TFieldValues>,\n      value: SetFieldValue<TFieldValues>,\n      config: SetValueConfig,\n    ) => {\n      !shouldUnregister &&\n        !isPrimitive(value) &&\n        set(shallowFieldsStateRef.current, name, { ...value });\n\n      if (fieldsRef.current[name]) {\n        setFieldValue(name, value);\n        config.shouldDirty && updateAndGetDirtyState(name);\n        config.shouldValidate && trigger(name as any);\n      } else if (!isPrimitive(value)) {\n        setInternalValues(name, value, config);\n\n        if (fieldArrayNamesRef.current.has(name)) {\n          const parentName = getNodeParentName(name) || name;\n          set(fieldArrayDefaultValuesRef.current, name, value);\n\n          resetFieldArrayFunctionRef.current[parentName]({\n            [parentName]: get(fieldArrayDefaultValuesRef.current, parentName),\n          } as UnpackNestedValue<DeepPartial<TFieldValues>>);\n\n          if (\n            (readFormStateRef.current.isDirty ||\n              readFormStateRef.current.dirtyFields) &&\n            config.shouldDirty\n          ) {\n            set(\n              formStateRef.current.dirtyFields,\n              name,\n              setFieldArrayDirtyFields(\n                value,\n                get(defaultValuesRef.current, name, []),\n                get(formStateRef.current.dirtyFields, name, []),\n              ),\n            );\n\n            updateFormState({\n              isDirty: !deepEqual(\n                { ...getValues(), [name]: value },\n                defaultValuesRef.current,\n              ),\n            });\n          }\n        }\n      }\n\n      !shouldUnregister && set(shallowFieldsStateRef.current, name, value);\n    },\n    [updateAndGetDirtyState, setFieldValue, setInternalValues],\n  );\n\n  const isFieldWatched = <T extends FieldName<TFieldValues>>(name: T) =>\n    isWatchAllRef.current ||\n    watchFieldsRef.current.has(name) ||\n    watchFieldsRef.current.has((name.match(/\\w+/) || [])[0]);\n\n  const renderWatchedInputs = <T extends FieldName<FieldValues>>(\n    name: T,\n  ): boolean => {\n    let found = true;\n\n    if (!isEmptyObject(useWatchFieldsRef.current)) {\n      for (const key in useWatchFieldsRef.current) {\n        if (\n          !name ||\n          !useWatchFieldsRef.current[key].size ||\n          useWatchFieldsRef.current[key].has(name) ||\n          useWatchFieldsRef.current[key].has(getNodeParentName(name))\n        ) {\n          useWatchRenderFunctionsRef.current[key]();\n          found = false;\n        }\n      }\n    }\n\n    return found;\n  };\n\n  function setValue(\n    name: FieldName<TFieldValues>,\n    value: SetFieldValue<TFieldValues>,\n    config?: SetValueConfig,\n  ): void {\n    setInternalValue(name, value, config || {});\n    isFieldWatched(name) && updateFormState();\n    renderWatchedInputs(name);\n  }\n\n  handleChangeRef.current = handleChangeRef.current\n    ? handleChangeRef.current\n    : async ({ type, target }: Event): Promise<void | boolean> => {\n        let name = (target as Ref)!.name;\n        const field = fieldsRef.current[name];\n        let error;\n        let isValid;\n\n        if (field) {\n          const isBlurEvent = type === EVENTS.BLUR;\n          const shouldSkipValidation = skipValidation({\n            isBlurEvent,\n            isReValidateOnChange,\n            isReValidateOnBlur,\n            isTouched: !!get(formStateRef.current.touched, name),\n            isSubmitted: formStateRef.current.isSubmitted,\n            ...modeRef.current,\n          });\n          let state = updateAndGetDirtyState(name, false);\n          let shouldRender =\n            !isEmptyObject(state) ||\n            (!isBlurEvent && isFieldWatched(name as FieldName<TFieldValues>));\n\n          if (\n            isBlurEvent &&\n            !get(formStateRef.current.touched, name) &&\n            readFormStateRef.current.touched\n          ) {\n            set(formStateRef.current.touched, name, true);\n            state = {\n              ...state,\n              touched: formStateRef.current.touched,\n            };\n          }\n\n          if (!shouldUnregister && isCheckBoxInput(target as Ref)) {\n            set(\n              shallowFieldsStateRef.current,\n              name,\n              getFieldValue(fieldsRef, name),\n            );\n          }\n\n          if (shouldSkipValidation) {\n            !isBlurEvent && renderWatchedInputs(name);\n            return (\n              (!isEmptyObject(state) ||\n                (shouldRender && isEmptyObject(state))) &&\n              updateFormState(state)\n            );\n          }\n\n          updateIsValidating();\n\n          if (resolverRef.current) {\n            const { errors } = await resolverRef.current(\n              getValues(),\n              contextRef.current,\n              isValidateAllFieldCriteria,\n            );\n            const previousFormIsValid = formStateRef.current.isValid;\n            error = get(errors, name);\n\n            if (\n              isCheckBoxInput(target as Ref) &&\n              !error &&\n              resolverRef.current\n            ) {\n              const parentNodeName = getNodeParentName(name);\n              const currentError = get(errors, parentNodeName, {});\n              currentError.type &&\n                currentError.message &&\n                (error = currentError);\n\n              if (\n                parentNodeName &&\n                (currentError ||\n                  get(formStateRef.current.errors, parentNodeName))\n              ) {\n                name = parentNodeName;\n              }\n            }\n\n            isValid = isEmptyObject(errors);\n\n            previousFormIsValid !== isValid && (shouldRender = true);\n          } else {\n            error = (\n              await validateField<TFieldValues>(\n                fieldsRef,\n                isValidateAllFieldCriteria,\n                field,\n                shallowFieldsStateRef,\n              )\n            )[name];\n          }\n\n          !isBlurEvent && renderWatchedInputs(name);\n          shouldRenderBaseOnError(name, error, shouldRender, state, isValid);\n        }\n      };\n\n  function setFieldArrayDefaultValues<T extends FieldValues>(data: T): T {\n    if (!shouldUnregister) {\n      let copy = cloneObject(data);\n\n      for (const value of fieldArrayNamesRef.current) {\n        if (isKey(value) && !copy[value]) {\n          copy = {\n            ...copy,\n            [value]: [],\n          };\n        }\n      }\n\n      return copy;\n    }\n    return data;\n  }\n\n  function getValues(): UnpackNestedValue<TFieldValues>;\n  function getValues<TFieldName extends string, TFieldValue extends unknown>(\n    name: TFieldName,\n  ): TFieldName extends keyof TFieldValues\n    ? UnpackNestedValue<TFieldValues>[TFieldName]\n    : TFieldValue;\n  function getValues<TFieldName extends keyof TFieldValues>(\n    names: TFieldName[],\n  ): UnpackNestedValue<Pick<TFieldValues, TFieldName>>;\n  function getValues(payload?: string | string[]): unknown {\n    if (isString(payload)) {\n      return getFieldValue(fieldsRef, payload, shallowFieldsStateRef);\n    }\n\n    if (Array.isArray(payload)) {\n      const data = {};\n\n      for (const name of payload) {\n        set(data, name, getFieldValue(fieldsRef, name, shallowFieldsStateRef));\n      }\n\n      return data;\n    }\n\n    return setFieldArrayDefaultValues(\n      getFieldsValues(\n        fieldsRef,\n        cloneObject(shallowFieldsStateRef.current),\n        shouldUnregister,\n      ),\n    );\n  }\n\n  const validateResolver = React.useCallback(\n    async (values = {}) => {\n      const newDefaultValues = isEmptyObject(fieldsRef.current)\n        ? defaultValuesRef.current\n        : {};\n\n      const { errors } =\n        (await resolverRef.current!(\n          {\n            ...newDefaultValues,\n            ...getValues(),\n            ...values,\n          },\n          contextRef.current,\n          isValidateAllFieldCriteria,\n        )) || {};\n      const isValid = isEmptyObject(errors);\n\n      formStateRef.current.isValid !== isValid &&\n        updateFormState({\n          isValid,\n        });\n    },\n    [isValidateAllFieldCriteria],\n  );\n\n  const removeFieldEventListener = React.useCallback(\n    (field: Field, forceDelete?: boolean) => {\n      findRemovedFieldAndRemoveListener(\n        fieldsRef,\n        handleChangeRef.current!,\n        field,\n        shallowFieldsStateRef,\n        shouldUnregister,\n        forceDelete,\n      );\n\n      if (shouldUnregister) {\n        unset(validFieldsRef.current, field.ref.name);\n        unset(fieldsWithValidationRef.current, field.ref.name);\n      }\n    },\n    [shouldUnregister],\n  );\n\n  const updateWatchedValue = React.useCallback((name: string) => {\n    if (isWatchAllRef.current) {\n      updateFormState();\n    } else {\n      for (const watchField of watchFieldsRef.current) {\n        if (watchField.startsWith(name)) {\n          updateFormState();\n          break;\n        }\n      }\n\n      renderWatchedInputs(name);\n    }\n  }, []);\n\n  const removeFieldEventListenerAndRef = React.useCallback(\n    (field?: Field, forceDelete?: boolean) => {\n      if (field) {\n        removeFieldEventListener(field, forceDelete);\n\n        if (shouldUnregister && !compact(field.options || []).length) {\n          unset(formStateRef.current.errors, field.ref.name);\n          set(formStateRef.current.dirtyFields, field.ref.name, true);\n\n          updateFormState({\n            isDirty: isFormDirty(),\n          });\n\n          readFormStateRef.current.isValid &&\n            resolverRef.current &&\n            validateResolver();\n          updateWatchedValue(field.ref.name);\n        }\n      }\n    },\n    [validateResolver, removeFieldEventListener],\n  );\n\n  function clearErrors(\n    name?: FieldName<TFieldValues> | FieldName<TFieldValues>[],\n  ): void {\n    name &&\n      (Array.isArray(name) ? name : [name]).forEach((inputName) =>\n        fieldsRef.current[inputName] && isKey(inputName)\n          ? delete formStateRef.current.errors[inputName]\n          : unset(formStateRef.current.errors, inputName),\n      );\n\n    updateFormState({\n      errors: name ? formStateRef.current.errors : {},\n    });\n  }\n\n  function setError(name: FieldName<TFieldValues>, error: ErrorOption) {\n    const ref = (fieldsRef.current[name] || {})!.ref;\n\n    set(formStateRef.current.errors, name, {\n      ...error,\n      ref,\n    });\n\n    updateFormState({\n      isValid: false,\n    });\n\n    error.shouldFocus && ref && ref.focus && ref.focus();\n  }\n\n  const watchInternal = React.useCallback(\n    <T>(fieldNames?: string | string[], defaultValue?: T, watchId?: string) => {\n      const watchFields = watchId\n        ? useWatchFieldsRef.current[watchId]\n        : watchFieldsRef.current;\n      let fieldValues = getFieldsValues<TFieldValues>(\n        fieldsRef,\n        cloneObject(shallowFieldsStateRef.current),\n        shouldUnregister,\n        false,\n        fieldNames,\n      );\n\n      if (isString(fieldNames)) {\n        const parentNodeName = getNodeParentName(fieldNames) || fieldNames;\n\n        if (fieldArrayNamesRef.current.has(parentNodeName)) {\n          fieldValues = {\n            ...fieldArrayValuesRef.current,\n            ...fieldValues,\n          };\n        }\n\n        return assignWatchFields<TFieldValues>(\n          fieldValues,\n          fieldNames,\n          watchFields,\n          isUndefined(get(defaultValuesRef.current, fieldNames))\n            ? defaultValue\n            : get(defaultValuesRef.current, fieldNames),\n          true,\n        );\n      }\n\n      const combinedDefaultValues = isUndefined(defaultValue)\n        ? defaultValuesRef.current\n        : defaultValue;\n\n      if (Array.isArray(fieldNames)) {\n        return fieldNames.reduce(\n          (previous, name) => ({\n            ...previous,\n            [name]: assignWatchFields<TFieldValues>(\n              fieldValues,\n              name,\n              watchFields,\n              combinedDefaultValues as UnpackNestedValue<\n                DeepPartial<TFieldValues>\n              >,\n            ),\n          }),\n          {},\n        );\n      }\n\n      isWatchAllRef.current = isUndefined(watchId);\n\n      return transformToNestObject(\n        (!isEmptyObject(fieldValues) && fieldValues) ||\n          (combinedDefaultValues as FieldValues),\n      );\n    },\n    [],\n  );\n\n  function watch(): UnpackNestedValue<TFieldValues>;\n  function watch<\n    TFieldName extends string,\n    TFieldValue extends TFieldValues[TFieldName]\n  >(\n    name?: TFieldName,\n    defaultValue?: UnpackNestedValue<LiteralToPrimitive<TFieldValue>>,\n  ): UnpackNestedValue<LiteralToPrimitive<TFieldValue>>;\n  function watch<TFieldName extends keyof TFieldValues>(\n    names: TFieldName[],\n    defaultValues?: UnpackNestedValue<\n      DeepPartial<Pick<TFieldValues, TFieldName>>\n    >,\n  ): UnpackNestedValue<Pick<TFieldValues, TFieldName>>;\n  function watch(\n    names: string[],\n    defaultValues?: UnpackNestedValue<DeepPartial<TFieldValues>>,\n  ): UnpackNestedValue<DeepPartial<TFieldValues>>;\n  function watch(\n    fieldNames?: string | string[] | undefined,\n    defaultValue?: unknown,\n  ): unknown {\n    return watchInternal(fieldNames, defaultValue);\n  }\n\n  function unregister(\n    name: FieldName<TFieldValues> | FieldName<TFieldValues>[],\n  ): void {\n    for (const fieldName of Array.isArray(name) ? name : [name]) {\n      removeFieldEventListenerAndRef(fieldsRef.current[fieldName], true);\n    }\n  }\n\n  function registerFieldRef<TFieldElement extends FieldElement<TFieldValues>>(\n    ref: TFieldElement & Ref,\n    options: RegisterOptions | null = {},\n  ): ((name: InternalFieldName<TFieldValues>) => void) | void {\n    if (process.env.NODE_ENV !== 'production') {\n      if (!ref.name) {\n        return console.warn(\n          '📋 Field is missing `name` attribute',\n          ref,\n          `https://react-hook-form.com/api#useForm`,\n        );\n      }\n\n      if (\n        fieldArrayNamesRef.current.has(ref.name.split(/\\[\\d+\\]$/)[0]) &&\n        !RegExp(\n          `^${ref.name.split(/\\[\\d+\\]$/)[0]}[\\\\d+].\\\\w+`\n            .replace(/\\[/g, '\\\\[')\n            .replace(/\\]/g, '\\\\]'),\n        ).test(ref.name)\n      ) {\n        return console.warn(\n          '📋 `name` prop should be in object shape: name=\"test[index].name\"',\n          ref,\n          'https://react-hook-form.com/api#useFieldArray',\n        );\n      }\n    }\n\n    const { name, type, value } = ref;\n    const fieldRefAndValidationOptions = {\n      ref,\n      ...options,\n    };\n    const fields = fieldsRef.current;\n    const isRadioOrCheckbox = isRadioOrCheckboxFunction(ref);\n    const isFieldArray = isNameInFieldArray(fieldArrayNamesRef.current, name);\n    const compareRef = (currentRef: Ref) =>\n      isWeb && (!isHTMLElement(ref) || currentRef === ref);\n    let field = fields[name] as Field;\n    let isEmptyDefaultValue = true;\n    let defaultValue;\n\n    if (\n      field &&\n      (isRadioOrCheckbox\n        ? Array.isArray(field.options) &&\n          compact(field.options).find((option) => {\n            return value === option.ref.value && compareRef(option.ref);\n          })\n        : compareRef(field.ref))\n    ) {\n      fields[name] = {\n        ...field,\n        ...options,\n      };\n      return;\n    }\n\n    if (type) {\n      field = isRadioOrCheckbox\n        ? {\n            options: [\n              ...compact((field && field.options) || []),\n              {\n                ref,\n              } as RadioOrCheckboxOption,\n            ],\n            ref: { type, name },\n            ...options,\n          }\n        : {\n            ...fieldRefAndValidationOptions,\n          };\n    } else {\n      field = fieldRefAndValidationOptions;\n    }\n\n    fields[name] = field;\n\n    const isEmptyUnmountFields = isUndefined(\n      get(shallowFieldsStateRef.current, name),\n    );\n\n    if (!isEmptyObject(defaultValuesRef.current) || !isEmptyUnmountFields) {\n      defaultValue = get(\n        isEmptyUnmountFields\n          ? defaultValuesRef.current\n          : shallowFieldsStateRef.current,\n        name,\n      );\n      isEmptyDefaultValue = isUndefined(defaultValue);\n\n      if (!isEmptyDefaultValue && !isFieldArray) {\n        setFieldValue(name as FieldName<TFieldValues>, defaultValue);\n      }\n    }\n\n    if (!isEmptyObject(options)) {\n      set(fieldsWithValidationRef.current, name, true);\n\n      if (!isOnSubmit && readFormStateRef.current.isValid) {\n        validateField(\n          fieldsRef,\n          isValidateAllFieldCriteria,\n          field,\n          shallowFieldsStateRef,\n        ).then((error: FieldErrors) => {\n          const previousFormIsValid = formStateRef.current.isValid;\n\n          isEmptyObject(error)\n            ? set(validFieldsRef.current, name, true)\n            : unset(validFieldsRef.current, name);\n\n          previousFormIsValid !== isEmptyObject(error) && updateFormState();\n        });\n      }\n    }\n\n    if (shouldUnregister && !(isFieldArray && isEmptyDefaultValue)) {\n      !isFieldArray && unset(formStateRef.current.dirtyFields, name);\n    }\n\n    if (type) {\n      attachEventListeners(\n        isRadioOrCheckbox && field.options\n          ? field.options[field.options.length - 1]\n          : field,\n        isRadioOrCheckbox || isSelectInput(ref),\n        handleChangeRef.current,\n      );\n    }\n  }\n\n  function register<TFieldElement extends FieldElement<TFieldValues>>(\n    options?: RegisterOptions,\n  ): (ref: (TFieldElement & Ref) | null) => void;\n  function register(\n    name: FieldName<TFieldValues>,\n    options?: RegisterOptions,\n  ): void;\n  function register<TFieldElement extends FieldElement<TFieldValues>>(\n    ref: (TFieldElement & Ref) | null,\n    options?: RegisterOptions,\n  ): void;\n  function register<TFieldElement extends FieldElement<TFieldValues>>(\n    refOrRegisterOptions?:\n      | FieldName<TFieldValues>\n      | RegisterOptions\n      | (TFieldElement & Ref)\n      | null,\n    options?: RegisterOptions,\n  ): ((ref: (TFieldElement & Ref) | null) => void) | void {\n    if (!isWindowUndefined) {\n      if (isString(refOrRegisterOptions)) {\n        registerFieldRef({ name: refOrRegisterOptions }, options);\n      } else if (\n        isObject(refOrRegisterOptions) &&\n        'name' in refOrRegisterOptions\n      ) {\n        registerFieldRef(refOrRegisterOptions, options);\n      } else {\n        return (ref: (TFieldElement & Ref) | null) =>\n          ref && registerFieldRef(ref, refOrRegisterOptions);\n      }\n    }\n  }\n\n  const handleSubmit = React.useCallback(\n    <TSubmitFieldValues extends FieldValues = TFieldValues>(\n      onValid: SubmitHandler<TSubmitFieldValues>,\n      onInvalid?: SubmitErrorHandler<TFieldValues>,\n    ) => async (e?: React.BaseSyntheticEvent): Promise<void> => {\n      if (e && e.preventDefault) {\n        e.preventDefault();\n        e.persist();\n      }\n      let fieldErrors: FieldErrors<TFieldValues> = {};\n      let fieldValues = setFieldArrayDefaultValues(\n        getFieldsValues(\n          fieldsRef,\n          cloneObject(shallowFieldsStateRef.current),\n          shouldUnregister,\n          true,\n        ),\n      );\n\n      readFormStateRef.current.isSubmitting &&\n        updateFormState({\n          isSubmitting: true,\n        });\n\n      try {\n        if (resolverRef.current) {\n          const { errors, values } = await resolverRef.current(\n            fieldValues,\n            contextRef.current,\n            isValidateAllFieldCriteria,\n          );\n          formStateRef.current.errors = fieldErrors = errors;\n          fieldValues = values;\n        } else {\n          for (const field of Object.values(fieldsRef.current)) {\n            if (field) {\n              const { name } = field.ref;\n\n              const fieldError = await validateField(\n                fieldsRef,\n                isValidateAllFieldCriteria,\n                field,\n                shallowFieldsStateRef,\n              );\n\n              if (fieldError[name]) {\n                set(fieldErrors, name, fieldError[name]);\n                unset(validFieldsRef.current, name);\n              } else if (get(fieldsWithValidationRef.current, name)) {\n                unset(formStateRef.current.errors, name);\n                set(validFieldsRef.current, name, true);\n              }\n            }\n          }\n        }\n\n        if (\n          isEmptyObject(fieldErrors) &&\n          Object.keys(formStateRef.current.errors).every(\n            (name) => name in fieldsRef.current,\n          )\n        ) {\n          updateFormState({\n            errors: {},\n            isSubmitting: true,\n          });\n          await onValid(fieldValues, e);\n        } else {\n          formStateRef.current.errors = {\n            ...formStateRef.current.errors,\n            ...fieldErrors,\n          };\n          onInvalid && (await onInvalid(formStateRef.current.errors, e));\n          shouldFocusError &&\n            focusOnErrorField(fieldsRef.current, formStateRef.current.errors);\n        }\n      } finally {\n        formStateRef.current.isSubmitting = false;\n        updateFormState({\n          isSubmitted: true,\n          isSubmitting: false,\n          isSubmitSuccessful: isEmptyObject(formStateRef.current.errors),\n          submitCount: formStateRef.current.submitCount + 1,\n        });\n      }\n    },\n    [shouldFocusError, isValidateAllFieldCriteria],\n  );\n\n  const resetRefs = ({\n    errors,\n    isDirty,\n    isSubmitted,\n    touched,\n    isValid,\n    submitCount,\n    dirtyFields,\n  }: OmitResetState) => {\n    if (!isValid) {\n      validFieldsRef.current = {};\n      fieldsWithValidationRef.current = {};\n    }\n\n    fieldArrayDefaultValuesRef.current = {};\n    watchFieldsRef.current = new Set();\n    isWatchAllRef.current = false;\n\n    updateFormState({\n      submitCount: submitCount ? formStateRef.current.submitCount : 0,\n      isDirty: isDirty ? formStateRef.current.isDirty : false,\n      isSubmitted: isSubmitted ? formStateRef.current.isSubmitted : false,\n      isValid: isValid ? formStateRef.current.isValid : false,\n      dirtyFields: dirtyFields ? formStateRef.current.dirtyFields : {},\n      touched: touched ? formStateRef.current.touched : {},\n      errors: errors ? formStateRef.current.errors : {},\n      isSubmitting: false,\n      isSubmitSuccessful: false,\n    });\n  };\n\n  const reset = (\n    values?: DefaultValues<TFieldValues>,\n    omitResetState: OmitResetState = {},\n  ): void => {\n    if (isWeb) {\n      for (const field of Object.values(fieldsRef.current)) {\n        if (field) {\n          const { ref, options } = field;\n          const inputRef =\n            isRadioOrCheckboxFunction(ref) && Array.isArray(options)\n              ? options[0].ref\n              : ref;\n\n          if (isHTMLElement(inputRef)) {\n            try {\n              inputRef.closest('form')!.reset();\n              break;\n            } catch {}\n          }\n        }\n      }\n    }\n\n    fieldsRef.current = {};\n    defaultValuesRef.current = { ...(values || defaultValuesRef.current) };\n    values && renderWatchedInputs('');\n\n    Object.values(resetFieldArrayFunctionRef.current).forEach(\n      (resetFieldArray) => isFunction(resetFieldArray) && resetFieldArray(),\n    );\n\n    shallowFieldsStateRef.current = shouldUnregister\n      ? {}\n      : cloneObject(values || defaultValuesRef.current);\n\n    resetRefs(omitResetState);\n  };\n\n  React.useEffect(() => {\n    resolver && readFormStateRef.current.isValid && validateResolver();\n    observerRef.current =\n      observerRef.current || !isWeb\n        ? observerRef.current\n        : onDomRemove(fieldsRef, removeFieldEventListenerAndRef);\n  }, [removeFieldEventListenerAndRef, defaultValuesRef.current]);\n\n  React.useEffect(\n    () => () => {\n      observerRef.current && observerRef.current.disconnect();\n      isUnMount.current = true;\n\n      if (process.env.NODE_ENV !== 'production') {\n        return;\n      }\n\n      Object.values(fieldsRef.current).forEach((field) =>\n        removeFieldEventListenerAndRef(field, true),\n      );\n    },\n    [],\n  );\n\n  if (!resolver && readFormStateRef.current.isValid) {\n    formState.isValid =\n      deepEqual(validFieldsRef.current, fieldsWithValidationRef.current) &&\n      isEmptyObject(formStateRef.current.errors);\n  }\n\n  const commonProps = {\n    trigger,\n    setValue: React.useCallback(setValue, [setInternalValue, trigger]),\n    getValues: React.useCallback(getValues, []),\n    register: React.useCallback(register, [defaultValuesRef.current]),\n    unregister: React.useCallback(unregister, []),\n    formState: isProxyEnabled\n      ? new Proxy(formState, {\n          get: (obj, prop: keyof FormStateProxy) => {\n            if (process.env.NODE_ENV !== 'production') {\n              if (prop === 'isValid' && isOnSubmit) {\n                console.warn(\n                  '📋 `formState.isValid` is applicable with `onTouched`, `onChange` or `onBlur` mode. https://react-hook-form.com/api#formState',\n                );\n              }\n            }\n\n            if (prop in obj) {\n              readFormStateRef.current[prop] = true;\n              return obj[prop];\n            }\n\n            return undefined;\n          },\n        })\n      : formState,\n  };\n\n  const control = React.useMemo(\n    () => ({\n      isFormDirty,\n      updateWatchedValue,\n      shouldUnregister,\n      updateFormState,\n      removeFieldEventListener,\n      watchInternal,\n      mode: modeRef.current,\n      reValidateMode: {\n        isReValidateOnBlur,\n        isReValidateOnChange,\n      },\n      validateResolver: resolver ? validateResolver : undefined,\n      fieldsRef,\n      resetFieldArrayFunctionRef,\n      useWatchFieldsRef,\n      useWatchRenderFunctionsRef,\n      fieldArrayDefaultValuesRef,\n      validFieldsRef,\n      fieldsWithValidationRef,\n      fieldArrayNamesRef,\n      readFormStateRef,\n      formStateRef,\n      defaultValuesRef,\n      shallowFieldsStateRef,\n      fieldArrayValuesRef,\n      ...commonProps,\n    }),\n    [\n      defaultValuesRef.current,\n      updateWatchedValue,\n      shouldUnregister,\n      removeFieldEventListener,\n      watchInternal,\n    ],\n  );\n\n  return {\n    watch,\n    control,\n    handleSubmit,\n    reset: React.useCallback(reset, []),\n    clearErrors: React.useCallback(clearErrors, []),\n    setError: React.useCallback(setError, []),\n    errors: formState.errors,\n    ...commonProps,\n  };\n}\n","import * as React from 'react';\nimport { UseFormMethods, FieldValues, FormProviderProps } from './types';\n\nconst FormContext = React.createContext<UseFormMethods | null>(null);\n\nFormContext.displayName = 'RHFContext';\n\nexport const useFormContext = <\n  TFieldValues extends FieldValues\n>(): UseFormMethods<TFieldValues> =>\n  React.useContext(FormContext) as UseFormMethods<TFieldValues>;\n\nexport const FormProvider = <TFieldValues extends FieldValues>({\n  children,\n  ...props\n}: FormProviderProps<TFieldValues>) => (\n  <FormContext.Provider value={{ ...props } as UseFormMethods}>\n    {children}\n  </FormContext.Provider>\n);\n","import { UNDEFINED } from '../constants';\n\nexport default () => {\n  const d =\n    typeof performance === UNDEFINED ? Date.now() : performance.now() * 1000;\n\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\n    const r = (Math.random() * 16 + d) % 16 | 0;\n\n    return (c == 'x' ? r : (r & 0x3) | 0x8).toString(16);\n  });\n};\n","import isUndefined from './isUndefined';\nimport compact from './compact';\n\nfunction removeAtIndexes<T>(data: T[], indexes: number[]): T[] {\n  let i = 0;\n  const temp = [...data];\n\n  for (const index of indexes) {\n    temp.splice(index - i, 1);\n    i++;\n  }\n\n  return compact(temp).length ? temp : [];\n}\n\nexport default <T>(data: T[], index?: number | number[]): T[] =>\n  isUndefined(index)\n    ? []\n    : removeAtIndexes(data, (Array.isArray(index) ? index : [index]).sort());\n","import isUndefined from './isUndefined';\n\nexport default <T>(\n  data: (T | undefined)[],\n  from: number,\n  to: number,\n): (T | undefined)[] => {\n  if (Array.isArray(data)) {\n    if (isUndefined(data[to])) {\n      data[to] = undefined;\n    }\n    data.splice(to, 0, data.splice(from, 1)[0]);\n    return data;\n  }\n\n  return [];\n};\n","export default <T>(data: T[], indexA: number, indexB: number): void => {\n  const temp = [data[indexB], data[indexA]];\n  data[indexA] = temp[0];\n  data[indexB] = temp[1];\n};\n","export default function prepend<T>(data: T[]): (T | undefined)[];\nexport default function prepend<T>(data: T[], value: T | T[]): T[];\nexport default function prepend<T>(\n  data: T[],\n  value?: T | T[],\n): (T | undefined)[] {\n  return [...(Array.isArray(value) ? value : [value || undefined]), ...data];\n}\n","export default function insert<T>(data: T[], index: number): (T | undefined)[];\nexport default function insert<T>(\n  data: T[],\n  index: number,\n  value: T | T[],\n): T[];\nexport default function insert<T>(\n  data: T[],\n  index: number,\n  value?: T | T[],\n): (T | undefined)[] {\n  return [\n    ...data.slice(0, index),\n    ...(Array.isArray(value) ? value : [value || undefined]),\n    ...data.slice(index),\n  ];\n}\n","export default <T>(value: T | T[]): undefined[] | undefined =>\n  Array.isArray(value) ? Array(value.length).fill(undefined) : undefined;\n","import isObject from './isObject';\n\nexport default <T>(value: T) =>\n  ((Array.isArray(value) ? value : [value]) as T[]).map((data) => {\n    if (isObject(data)) {\n      const object: Record<string, boolean> = {};\n\n      for (const key in data) {\n        object[key] = true;\n      }\n\n      return object;\n    }\n\n    return true;\n  });\n","import * as React from 'react';\nimport { useFormContext } from './useFormContext';\nimport setFieldArrayDirtyFields from './logic/setFieldArrayDirtyFields';\nimport { isMatchFieldArrayName } from './logic/isNameInFieldArray';\nimport generateId from './logic/generateId';\nimport getFieldArrayParentName from './logic/getNodeParentName';\nimport get from './utils/get';\nimport set from './utils/set';\nimport removeArrayAt from './utils/remove';\nimport unset from './utils/unset';\nimport moveArrayAt from './utils/move';\nimport swapArrayAt from './utils/swap';\nimport prependAt from './utils/prepend';\nimport insertAt from './utils/insert';\nimport fillEmptyArray from './utils/fillEmptyArray';\nimport fillBooleanArray from './utils/fillBooleanArray';\nimport compact from './utils/compact';\nimport cloneObject from './utils/cloneObject';\nimport {\n  Field,\n  FieldValues,\n  UseFieldArrayOptions,\n  Control,\n  ArrayField,\n  UnpackNestedValue,\n  DeepPartial,\n  UseFieldArrayMethods,\n} from './types';\n\nconst mapIds = <\n  TFieldArrayValues extends FieldValues = FieldValues,\n  TKeyName extends string = 'id'\n>(\n  values: Partial<TFieldArrayValues>[] = [],\n  keyName: TKeyName,\n  skipWarn?: boolean,\n): Partial<ArrayField<TFieldArrayValues, TKeyName>>[] => {\n  if (process.env.NODE_ENV !== 'production') {\n    if (!skipWarn) {\n      for (const value of values) {\n        if (typeof value === 'object') {\n          if (keyName in value) {\n            console.warn(\n              `📋 useFieldArray fieldValues contain the keyName \\`${keyName}\\` which is reserved for use by useFieldArray. https://react-hook-form.com/api#useFieldArray`,\n            );\n\n            break;\n          }\n        } else {\n          console.warn(\n            `📋 useFieldArray input's name should be in object shape instead of flat array. https://react-hook-form.com/api#useFieldArray`,\n          );\n\n          break;\n        }\n      }\n    }\n  }\n\n  return values.map((value: Partial<TFieldArrayValues>) => ({\n    [keyName]: value[keyName] || generateId(),\n    ...value,\n  }));\n};\n\nexport const useFieldArray = <\n  TFieldArrayValues extends FieldValues = FieldValues,\n  TKeyName extends string = 'id',\n  TControl extends Control = Control\n>({\n  control,\n  name,\n  keyName = 'id' as TKeyName,\n}: UseFieldArrayOptions<TKeyName, TControl>): UseFieldArrayMethods<\n  TFieldArrayValues,\n  TKeyName\n> => {\n  const methods = useFormContext();\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (!control && !methods) {\n      throw new Error(\n        '📋 useFieldArray is missing `control` prop. https://react-hook-form.com/api#useFieldArray',\n      );\n    }\n  }\n\n  const focusIndexRef = React.useRef(-1);\n  const isUnMount = React.useRef(false);\n  const {\n    isFormDirty,\n    updateWatchedValue,\n    resetFieldArrayFunctionRef,\n    fieldArrayNamesRef,\n    fieldsRef,\n    defaultValuesRef,\n    removeFieldEventListener,\n    formStateRef,\n    shallowFieldsStateRef,\n    updateFormState,\n    readFormStateRef,\n    validFieldsRef,\n    fieldsWithValidationRef,\n    fieldArrayDefaultValuesRef,\n    validateResolver,\n    getValues,\n    shouldUnregister,\n    fieldArrayValuesRef,\n  } = control || methods.control;\n\n  const getDefaultValues = <T>(values: T) =>\n    get(shouldUnregister ? values : shallowFieldsStateRef.current, name, []);\n\n  const fieldArrayParentName = getFieldArrayParentName(name);\n  const memoizedDefaultValues = React.useRef<Partial<TFieldArrayValues>[]>([\n    ...(get(fieldArrayDefaultValuesRef.current, fieldArrayParentName)\n      ? getDefaultValues(fieldArrayDefaultValuesRef.current)\n      : getDefaultValues(defaultValuesRef.current)),\n  ]);\n  const [fields, setFields] = React.useState<\n    Partial<ArrayField<TFieldArrayValues, TKeyName>>[]\n  >(mapIds(memoizedDefaultValues.current, keyName));\n  set(fieldArrayValuesRef.current, name, fields);\n\n  const omitKey = <T extends (Partial<TFieldArrayValues> | undefined)[]>(\n    fields: T,\n  ) => fields.map(({ [keyName]: omitted, ...rest } = {}) => rest);\n\n  fieldArrayNamesRef.current.add(name);\n\n  const getFieldArrayValue = React.useCallback(\n    () => get(fieldArrayValuesRef.current, name, []),\n    [name],\n  );\n\n  const getCurrentFieldsValues = () =>\n    mapIds<TFieldArrayValues, TKeyName>(\n      get(getValues(), name, getFieldArrayValue()).map(\n        (item: Partial<TFieldArrayValues>, index: number) => ({\n          ...getFieldArrayValue()[index],\n          ...item,\n        }),\n      ),\n      keyName,\n      true,\n    );\n\n  fieldArrayNamesRef.current.add(name);\n\n  if (\n    fieldArrayParentName &&\n    !get(fieldArrayDefaultValuesRef.current, fieldArrayParentName)\n  ) {\n    set(\n      fieldArrayDefaultValuesRef.current,\n      fieldArrayParentName,\n      cloneObject(get(defaultValuesRef.current, fieldArrayParentName)),\n    );\n  }\n\n  const setFieldAndValidState = (\n    fieldsValues: Partial<ArrayField<TFieldArrayValues, TKeyName>>[],\n  ) => {\n    setFields(fieldsValues);\n    set(fieldArrayValuesRef.current, name, fieldsValues);\n\n    if (readFormStateRef.current.isValid && validateResolver) {\n      const values = getValues();\n      set(values, name, fieldsValues);\n      validateResolver(values);\n    }\n  };\n\n  const resetFields = () => {\n    for (const key in fieldsRef.current) {\n      if (isMatchFieldArrayName(key, name)) {\n        removeFieldEventListener(fieldsRef.current[key] as Field, true);\n        delete fieldsRef.current[key];\n      }\n    }\n  };\n\n  const cleanup = <T>(ref: T) =>\n    !compact(get(ref, name, [])).length && unset(ref, name);\n\n  const updateDirtyFieldsWithDefaultValues = <\n    T extends (Partial<TFieldArrayValues> | undefined)[]\n  >(\n    updatedFieldArrayValues?: T,\n  ) => {\n    if (updatedFieldArrayValues) {\n      set(\n        formStateRef.current.dirtyFields,\n        name,\n        setFieldArrayDirtyFields(\n          omitKey(updatedFieldArrayValues),\n          get(defaultValuesRef.current, name, []),\n          get(formStateRef.current.dirtyFields, name, []),\n        ),\n      );\n    }\n  };\n\n  const batchStateUpdate = <\n    T extends Function,\n    K extends (Partial<TFieldArrayValues> | undefined)[]\n  >(\n    method: T,\n    args: {\n      argA?: unknown;\n      argB?: unknown;\n      argC?: unknown;\n      argD?: unknown;\n    },\n    updatedFieldValues?: K,\n    updatedFormValues: (Partial<TFieldArrayValues> | undefined)[] = [],\n    shouldSet = true,\n    shouldUpdateValid = false,\n  ) => {\n    if (get(shallowFieldsStateRef.current, name)) {\n      const output = method(\n        get(shallowFieldsStateRef.current, name),\n        args.argA,\n        args.argB,\n      );\n      shouldSet && set(shallowFieldsStateRef.current, name, output);\n    }\n\n    if (get(fieldArrayDefaultValuesRef.current, name)) {\n      const output = method(\n        get(fieldArrayDefaultValuesRef.current, name),\n        args.argA,\n        args.argB,\n      );\n      shouldSet && set(fieldArrayDefaultValuesRef.current, name, output);\n    }\n\n    if (Array.isArray(get(formStateRef.current.errors, name))) {\n      const output = method(\n        get(formStateRef.current.errors, name),\n        args.argA,\n        args.argB,\n      );\n      shouldSet && set(formStateRef.current.errors, name, output);\n      cleanup(formStateRef.current.errors);\n    }\n\n    if (\n      readFormStateRef.current.touched &&\n      get(formStateRef.current.touched, name)\n    ) {\n      const output = method(\n        get(formStateRef.current.touched, name),\n        args.argA,\n        args.argB,\n      );\n      shouldSet && set(formStateRef.current.touched, name, output);\n      cleanup(formStateRef.current.touched);\n    }\n\n    if (\n      readFormStateRef.current.dirtyFields ||\n      readFormStateRef.current.isDirty\n    ) {\n      set(\n        formStateRef.current.dirtyFields,\n        name,\n        setFieldArrayDirtyFields(\n          omitKey(updatedFormValues),\n          get(defaultValuesRef.current, name, []),\n          get(formStateRef.current.dirtyFields, name, []),\n        ),\n      );\n      updateDirtyFieldsWithDefaultValues(updatedFieldValues);\n      cleanup(formStateRef.current.dirtyFields);\n    }\n\n    if (\n      shouldUpdateValid &&\n      readFormStateRef.current.isValid &&\n      !validateResolver\n    ) {\n      set(\n        validFieldsRef.current,\n        name,\n        method(get(validFieldsRef.current, name, []), args.argA),\n      );\n      cleanup(validFieldsRef.current);\n\n      set(\n        fieldsWithValidationRef.current,\n        name,\n        method(get(fieldsWithValidationRef.current, name, []), args.argA),\n      );\n      cleanup(fieldsWithValidationRef.current);\n    }\n\n    if (!isUnMount.current && readFormStateRef.current.isDirty) {\n      updateFormState({\n        isDirty: isFormDirty(name, omitKey(updatedFormValues)),\n      });\n    }\n  };\n\n  const append = (\n    value: Partial<TFieldArrayValues> | Partial<TFieldArrayValues>[],\n    shouldFocus = true,\n  ) => {\n    const appendValue = Array.isArray(value) ? value : [value];\n    const updateFormValues = [\n      ...getCurrentFieldsValues(),\n      ...mapIds(appendValue, keyName),\n    ];\n    setFieldAndValidState(updateFormValues);\n\n    if (\n      readFormStateRef.current.dirtyFields ||\n      readFormStateRef.current.isDirty\n    ) {\n      updateDirtyFieldsWithDefaultValues(updateFormValues);\n\n      updateFormState({\n        isDirty: true,\n        dirtyFields: formStateRef.current.dirtyFields,\n      });\n    }\n\n    !shouldUnregister &&\n      set(shallowFieldsStateRef.current, name, [\n        ...(get(shallowFieldsStateRef.current, name) || []),\n        ...cloneObject(appendValue),\n      ]);\n\n    focusIndexRef.current = shouldFocus\n      ? get(fieldArrayValuesRef.current, name).length - 1\n      : -1;\n  };\n\n  const prepend = (\n    value: Partial<TFieldArrayValues> | Partial<TFieldArrayValues>[],\n    shouldFocus = true,\n  ) => {\n    const emptyArray = fillEmptyArray(value);\n    const updatedFieldArrayValues = prependAt(\n      getCurrentFieldsValues(),\n      mapIds(Array.isArray(value) ? value : [value], keyName),\n    );\n\n    setFieldAndValidState(updatedFieldArrayValues);\n    resetFields();\n    batchStateUpdate(\n      prependAt,\n      {\n        argA: emptyArray,\n        argC: fillBooleanArray(value),\n      },\n      updatedFieldArrayValues,\n    );\n    focusIndexRef.current = shouldFocus ? 0 : -1;\n  };\n\n  const remove = (index?: number | number[]) => {\n    const fieldValues = getCurrentFieldsValues();\n    const updatedFieldValues: (\n      | Partial<TFieldArrayValues>\n      | undefined\n    )[] = removeArrayAt(fieldValues, index);\n    setFieldAndValidState(\n      updatedFieldValues as Partial<ArrayField<TFieldArrayValues, TKeyName>>[],\n    );\n    resetFields();\n    batchStateUpdate(\n      removeArrayAt,\n      {\n        argA: index,\n        argC: index,\n      },\n      updatedFieldValues,\n      removeArrayAt(fieldValues, index),\n      true,\n      true,\n    );\n  };\n\n  const insert = (\n    index: number,\n    value: Partial<TFieldArrayValues> | Partial<TFieldArrayValues>[],\n    shouldFocus = true,\n  ) => {\n    const emptyArray = fillEmptyArray(value);\n    const fieldValues = getCurrentFieldsValues();\n    const updatedFieldArrayValues = insertAt(\n      fieldValues,\n      index,\n      mapIds(Array.isArray(value) ? value : [value], keyName),\n    );\n\n    setFieldAndValidState(updatedFieldArrayValues);\n    resetFields();\n    batchStateUpdate(\n      insertAt,\n      {\n        argA: index,\n        argB: emptyArray,\n        argC: index,\n        argD: fillBooleanArray(value),\n      },\n      updatedFieldArrayValues,\n      insertAt(fieldValues, index),\n    );\n    focusIndexRef.current = shouldFocus ? index : -1;\n  };\n\n  const swap = (indexA: number, indexB: number) => {\n    const fieldValues = getCurrentFieldsValues();\n    swapArrayAt(fieldValues, indexA, indexB);\n    resetFields();\n    setFieldAndValidState([...fieldValues]);\n    batchStateUpdate(\n      swapArrayAt,\n      {\n        argA: indexA,\n        argB: indexB,\n        argC: indexA,\n        argD: indexB,\n      },\n      undefined,\n      fieldValues,\n      false,\n    );\n  };\n\n  const move = (from: number, to: number) => {\n    const fieldValues = getCurrentFieldsValues();\n    moveArrayAt(fieldValues, from, to);\n    resetFields();\n    setFieldAndValidState([...fieldValues]);\n    batchStateUpdate(\n      moveArrayAt,\n      {\n        argA: from,\n        argB: to,\n        argC: from,\n        argD: to,\n      },\n      undefined,\n      fieldValues,\n      false,\n    );\n  };\n\n  React.useEffect(() => {\n    if (process.env.NODE_ENV !== 'production') {\n      if (!name) {\n        console.warn(\n          '📋 useFieldArray is missing `name` attribute. https://react-hook-form.com/api#useFieldArray',\n        );\n      }\n    }\n\n    const defaultValues = get(fieldArrayDefaultValuesRef.current, name);\n\n    if (defaultValues && fields.length < defaultValues.length) {\n      set(fieldArrayDefaultValuesRef.current, name, defaultValues.slice(1));\n    }\n\n    updateWatchedValue(name);\n\n    if (focusIndexRef.current > -1) {\n      for (const key in fieldsRef.current) {\n        const field = fieldsRef.current[key];\n        if (\n          key.startsWith(`${name}[${focusIndexRef.current}]`) &&\n          field!.ref.focus\n        ) {\n          field!.ref.focus();\n          break;\n        }\n      }\n    }\n\n    focusIndexRef.current = -1;\n  }, [fields, name]);\n\n  React.useEffect(() => {\n    const resetFunctions = resetFieldArrayFunctionRef.current;\n    const fieldArrayNames = fieldArrayNamesRef.current;\n\n    if (!getFieldArrayParentName(name)) {\n      resetFunctions[name] = <TFieldValues>(\n        data?: UnpackNestedValue<DeepPartial<TFieldValues>>,\n      ) => {\n        resetFields();\n        !data && unset(fieldArrayDefaultValuesRef.current, name);\n        unset(shallowFieldsStateRef.current, name);\n        memoizedDefaultValues.current = get(\n          data || defaultValuesRef.current,\n          name,\n        );\n        if (!isUnMount.current) {\n          setFields(mapIds(memoizedDefaultValues.current, keyName));\n        }\n      };\n    }\n\n    return () => {\n      isUnMount.current = true;\n      shouldUnregister && remove();\n      resetFields();\n      delete resetFunctions[name];\n      unset(fieldArrayValuesRef.current, name);\n      fieldArrayNames.delete(name);\n    };\n  }, []);\n\n  return {\n    swap: React.useCallback(swap, [name]),\n    move: React.useCallback(move, [name]),\n    prepend: React.useCallback(prepend, [name]),\n    append: React.useCallback(append, [name]),\n    remove: React.useCallback(remove, [name]),\n    insert: React.useCallback(insert, [name]),\n    fields,\n  };\n};\n","import isUndefined from '../utils/isUndefined';\nimport isObject from '../utils/isObject';\nimport isPrimitive from '../utils/isPrimitive';\n\nexport default (event: any) =>\n  isPrimitive(event) ||\n  !isObject(event.target) ||\n  (isObject(event.target) && !event.type)\n    ? event\n    : isUndefined(event.target.value)\n    ? event.target.checked\n    : event.target.value;\n","import { useFormContext } from './useFormContext';\nimport isNameInFieldArray from './logic/isNameInFieldArray';\nimport isUndefined from './utils/isUndefined';\nimport get from './utils/get';\nimport * as React from 'react';\nimport isFunction from './utils/isFunction';\nimport skipValidation from './logic/skipValidation';\nimport getInputValue from './logic/getInputValue';\nimport set from './utils/set';\nimport {\n  FieldValues,\n  UseControllerOptions,\n  UseControllerMethods,\n} from './types';\n\nexport function useController<TFieldValues extends FieldValues = FieldValues>({\n  name,\n  rules,\n  defaultValue,\n  control,\n  onFocus,\n}: UseControllerOptions<TFieldValues>): UseControllerMethods<TFieldValues> {\n  const methods = useFormContext<TFieldValues>();\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (!control && !methods) {\n      throw new Error(\n        '📋 Controller is missing `control` prop. https://react-hook-form.com/api#Controller',\n      );\n    }\n  }\n\n  const {\n    defaultValuesRef,\n    setValue,\n    register,\n    unregister,\n    trigger,\n    mode,\n    reValidateMode: { isReValidateOnBlur, isReValidateOnChange },\n    formState,\n    formStateRef: {\n      current: { isSubmitted, touched, errors },\n    },\n    updateFormState,\n    readFormStateRef,\n    fieldsRef,\n    fieldArrayNamesRef,\n    shallowFieldsStateRef,\n  } = control || methods.control;\n\n  const isNotFieldArray = !isNameInFieldArray(fieldArrayNamesRef.current, name);\n  const getInitialValue = () =>\n    !isUndefined(get(shallowFieldsStateRef.current, name)) && isNotFieldArray\n      ? get(shallowFieldsStateRef.current, name)\n      : isUndefined(defaultValue)\n      ? get(defaultValuesRef.current, name)\n      : defaultValue;\n  const [value, setInputStateValue] = React.useState(getInitialValue());\n  const valueRef = React.useRef(value);\n  const ref = React.useRef({\n    focus: () => null,\n  });\n  const onFocusRef = React.useRef(\n    onFocus ||\n      (() => {\n        if (isFunction(ref.current.focus)) {\n          ref.current.focus();\n        }\n\n        if (process.env.NODE_ENV !== 'production') {\n          if (!isFunction(ref.current.focus)) {\n            console.warn(\n              `📋 'ref' from Controller render prop must be attached to a React component or a DOM Element whose ref provides a 'focus()' method`,\n            );\n          }\n        }\n      }),\n  );\n\n  const shouldValidate = React.useCallback(\n    (isBlurEvent?: boolean) =>\n      !skipValidation({\n        isBlurEvent,\n        isReValidateOnBlur,\n        isReValidateOnChange,\n        isSubmitted,\n        isTouched: !!get(touched, name),\n        ...mode,\n      }),\n    [\n      isReValidateOnBlur,\n      isReValidateOnChange,\n      isSubmitted,\n      touched,\n      name,\n      mode,\n    ],\n  );\n\n  const commonTask = React.useCallback(([event]: any[]) => {\n    const data = getInputValue(event);\n    setInputStateValue(data);\n    valueRef.current = data;\n    return data;\n  }, []);\n\n  const registerField = React.useCallback(\n    (shouldUpdateValue?: boolean) => {\n      if (process.env.NODE_ENV !== 'production') {\n        if (!name) {\n          return console.warn(\n            '📋 Field is missing `name` prop. https://react-hook-form.com/api#Controller',\n          );\n        }\n      }\n\n      if (fieldsRef.current[name]) {\n        fieldsRef.current[name] = {\n          ref: fieldsRef.current[name]!.ref,\n          ...rules,\n        };\n      } else {\n        register(\n          Object.defineProperties(\n            {\n              name,\n              focus: onFocusRef.current,\n            },\n            {\n              value: {\n                set(data) {\n                  setInputStateValue(data);\n                  valueRef.current = data;\n                },\n                get() {\n                  return valueRef.current;\n                },\n              },\n            },\n          ),\n          rules,\n        );\n\n        shouldUpdateValue = isUndefined(get(defaultValuesRef.current, name));\n      }\n\n      shouldUpdateValue &&\n        isNotFieldArray &&\n        setInputStateValue(getInitialValue());\n    },\n    [rules, name, register],\n  );\n\n  React.useEffect(() => () => unregister(name), [name]);\n\n  React.useEffect(() => {\n    if (process.env.NODE_ENV !== 'production') {\n      if (isUndefined(value)) {\n        console.warn(\n          `📋 ${name} is missing in the 'defaultValue' prop of either its Controller (https://react-hook-form.com/api#Controller) or useForm (https://react-hook-form.com/api#useForm)`,\n        );\n      }\n\n      if (!isNotFieldArray && isUndefined(defaultValue)) {\n        console.warn(\n          '📋 Controller is missing `defaultValue` prop when using `useFieldArray`. https://react-hook-form.com/api#Controller',\n        );\n      }\n    }\n\n    registerField();\n  }, [registerField]);\n\n  React.useEffect(() => {\n    !fieldsRef.current[name] && registerField(true);\n  });\n\n  const onBlur = React.useCallback(() => {\n    if (readFormStateRef.current.touched && !get(touched, name)) {\n      set(touched, name, true);\n      updateFormState({\n        touched,\n      });\n    }\n\n    shouldValidate(true) && trigger(name);\n  }, [name, updateFormState, shouldValidate, trigger, readFormStateRef]);\n\n  const onChange = React.useCallback(\n    (...event: any[]) =>\n      setValue(name, commonTask(event), {\n        shouldValidate: shouldValidate(),\n        shouldDirty: true,\n      }),\n    [setValue, name, shouldValidate],\n  );\n\n  return {\n    field: {\n      onChange,\n      onBlur,\n      name,\n      value,\n      ref,\n    },\n    meta: Object.defineProperties(\n      {\n        invalid: !!get(errors, name),\n      },\n      {\n        isDirty: {\n          get() {\n            return !!get(formState.dirtyFields, name);\n          },\n        },\n        isTouched: {\n          get() {\n            return !!get(formState.touched, name);\n          },\n        },\n      },\n    ),\n  };\n}\n","import * as React from 'react';\nimport { useFormContext } from './useFormContext';\nimport isUndefined from './utils/isUndefined';\nimport isString from './utils/isString';\nimport generateId from './logic/generateId';\nimport get from './utils/get';\nimport {\n  DeepPartial,\n  UseWatchOptions,\n  FieldValues,\n  UnpackNestedValue,\n  Control,\n} from './types';\n\nexport function useWatch<TWatchFieldValues extends FieldValues>(props: {\n  defaultValue?: UnpackNestedValue<DeepPartial<TWatchFieldValues>>;\n  control?: Control;\n}): UnpackNestedValue<DeepPartial<TWatchFieldValues>>;\nexport function useWatch<TWatchFieldValue extends any>(props: {\n  name: string;\n  control?: Control;\n}): undefined | UnpackNestedValue<TWatchFieldValue>;\nexport function useWatch<TWatchFieldValue extends any>(props: {\n  name: string;\n  defaultValue: UnpackNestedValue<TWatchFieldValue>;\n  control?: Control;\n}): UnpackNestedValue<TWatchFieldValue>;\nexport function useWatch<TWatchFieldValues extends FieldValues>(props: {\n  name: string[];\n  defaultValue?: UnpackNestedValue<DeepPartial<TWatchFieldValues>>;\n  control?: Control;\n}): UnpackNestedValue<DeepPartial<TWatchFieldValues>>;\nexport function useWatch<TWatchFieldValues>({\n  control,\n  name,\n  defaultValue,\n}: UseWatchOptions): TWatchFieldValues {\n  const methods = useFormContext();\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (!control && !methods) {\n      throw new Error(\n        '📋 useWatch is missing `control` prop. https://react-hook-form.com/api#useWatch',\n      );\n    }\n  }\n\n  const {\n    useWatchFieldsRef,\n    useWatchRenderFunctionsRef,\n    watchInternal,\n    defaultValuesRef,\n  } = control || methods.control;\n  const updateValue = React.useState<unknown>()[1];\n  const idRef = React.useRef<string>();\n  const defaultValueRef = React.useRef(defaultValue);\n\n  React.useEffect(() => {\n    if (process.env.NODE_ENV !== 'production') {\n      if (name === '') {\n        console.warn(\n          '📋 useWatch is missing `name` attribute. https://react-hook-form.com/api#useWatch',\n        );\n      }\n    }\n\n    const id = (idRef.current = generateId());\n    const watchFieldsHookRender = useWatchRenderFunctionsRef.current;\n    const watchFieldsHook = useWatchFieldsRef.current;\n    watchFieldsHook[id] = new Set();\n    watchFieldsHookRender[id] = () => updateValue({});\n    watchInternal(name, defaultValueRef.current, id);\n\n    return () => {\n      delete watchFieldsHook[id];\n      delete watchFieldsHookRender[id];\n    };\n  }, [\n    name,\n    useWatchRenderFunctionsRef,\n    useWatchFieldsRef,\n    watchInternal,\n    defaultValueRef,\n  ]);\n\n  return idRef.current\n    ? watchInternal(name, defaultValueRef.current, idRef.current)\n    : isUndefined(defaultValue)\n    ? isString(name)\n      ? get(defaultValuesRef.current, name)\n      : Array.isArray(name)\n      ? name.reduce(\n          (previous, inputName) => ({\n            ...previous,\n            [inputName]: get(defaultValuesRef.current, inputName),\n          }),\n          {},\n        )\n      : defaultValuesRef.current\n    : defaultValue;\n}\n","import * as React from 'react';\nimport { useController } from './useController';\nimport { ControllerProps, FieldValues } from './types';\n\ntype NativeInputs = 'input' | 'select' | 'textarea';\n\nconst Controller = <\n  TAs extends React.ReactElement | React.ComponentType<any> | NativeInputs,\n  TFieldValues extends FieldValues = FieldValues\n>(\n  props: ControllerProps<TAs, TFieldValues>,\n) => {\n  const { rules, as, render, defaultValue, control, onFocus, ...rest } = props;\n  const { field, meta } = useController(props);\n\n  const componentProps = {\n    ...rest,\n    ...field,\n  };\n\n  return as\n    ? React.isValidElement(as)\n      ? React.cloneElement(as, componentProps)\n      : React.createElement(as as NativeInputs, componentProps as any)\n    : render\n    ? render(field, meta)\n    : null;\n};\n\nexport { Controller };\n"]},"metadata":{},"sourceType":"module"}